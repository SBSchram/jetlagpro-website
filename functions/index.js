/**
 * JetLagPro Cloud Functions
 * 
 * Functions:
 * 1. auditLoggerCreate/Update/Delete - Logs all tripCompletions writes to both Firestore and GCS
 * 2. hmacValidator - Validates HMAC signatures on trip creation
 * 3. metadataValidator - Checks metadata consistency (device IDs, timestamps, builds)
 * 4. hourlyDigestNotification - Sends hourly email digest of new Firebase entries via Gmail
 */

const {setGlobalOptions} = require("firebase-functions/v2");
const {onDocumentCreated, onDocumentUpdated, onDocumentDeleted} = require("firebase-functions/v2/firestore");
const {onSchedule} = require("firebase-functions/v2/scheduler");
const {initializeApp} = require("firebase-admin/app");
const {getFirestore, FieldValue, Timestamp} = require("firebase-admin/firestore");
const {Storage} = require("@google-cloud/storage");
const logger = require("firebase-functions/logger");
const crypto = require("crypto");
const nodemailer = require("nodemailer");
const functions = require("firebase-functions");

// Initialize Firebase Admin
initializeApp();
const db = getFirestore();

// Initialize Google Cloud Storage
const storage = new Storage();
const auditBucket = storage.bucket("jetlagpro-audit-logs");

// Set global options for cost control
setGlobalOptions({
  maxInstances: 10,
  region: "us-east1", // Match your Firestore region
});

// HMAC Secret Key (same as iOS/RN apps)
// 
// SECURITY: This key is intentionally public for research transparency, enabling
// independent verification by third parties. Keeping it public is safe because:
// 
// 1. The HMAC secret alone is insufficient to create valid trips - attackers still need:
//    - A legitimate device ID (generated by real iOS devices with the app installed)
//    - To pass metadata validation (device ID format, timestamps, build numbers)
//    - Proper Firestore write authentication
// 
// 2. Multiple validation layers protect against fake data:
//    - HMAC signature validation (requires secret + legitimate device ID)
//    - Metadata validation (validates device ID format and consistency)
//    - Source validation (tracks data origin)
// 
// 3. Research transparency outweighs the minimal security risk:
//    - Reviewers can verify trip authenticity independently without requesting keys
//    - Public verification increases trust in research data
//    - The combination of secret + device ID still ensures data authenticity
//
// This matches the public key in verify_trip_signatures.py for consistency.
const HMAC_SECRET = "7f3a9d8b2c4e1f6a5d8b3c9e7f2a4d6b8c1e3f5a7d9b2c4e6f8a1d3b5c7e9f2a";

// Email Notification Configuration
const NOTIFICATION_EMAIL = "sbschram@gmail.com";
const NOTIFICATION_SETTINGS_DOC = "notificationSettings";
const NOTIFICATION_SETTINGS_COLLECTION = "_system";

// Gmail Email Transporter (requires app-specific password with 2FA enabled)
let emailTransporter = null;

function getEmailTransporter() {
  if (emailTransporter) return emailTransporter;

  // Try to get from functions.config() first (for compatibility), then fall back to process.env
  let gmailPassword;
  let gmailUser;
  
  try {
    gmailPassword = functions.config().gmail?.password;
    gmailUser = functions.config().gmail?.user;
  } catch (e) {
    // functions.config() not available in v2, use process.env
    gmailPassword = process.env.GMAIL_PASSWORD;
    gmailUser = process.env.GMAIL_USER;
  }
  
  if (!gmailPassword) {
    logger.warn("‚ö†Ô∏è Gmail app password not set. Run: firebase functions:config:set gmail.password=YOUR_PASSWORD");
    return null;
  }

  gmailUser = gmailUser || "sbschram@gmail.com";
  emailTransporter = nodemailer.createTransport({
    service: "gmail",
    auth: { user: gmailUser, pass: gmailPassword },
  });
  
  return emailTransporter;
}

/**
 * Writes audit entry to both Firestore (real-time) and GCS (immutable).
 * 
 * @param {Object} auditEntry - The audit log entry to write
 * @return {Promise<void>}
 */
async function writeAuditEntry(auditEntry) {
  try {
    // 1. Write to Firestore (for real-time viewing)
    const firestoreRef = await db.collection("auditLog").add(auditEntry);
    logger.info(`‚úÖ Firestore: Audit entry written (${firestoreRef.id})`);

    // 2. Write to GCS (immutable archive)
    const timestamp = Date.now();
    const operation = auditEntry.operation || "UNKNOWN";
    const tripId = auditEntry.tripId || auditEntry.documentId || "unknown";
    const fileName = `${timestamp}-${operation}-${tripId}.json`;
    const file = auditBucket.file(`audit-logs/${fileName}`);

    // Prepare entry for GCS (convert Firestore timestamps to ISO strings)
    // Recursively process the entry to normalize timestamps
    const normalizeForGCS = (obj) => {
      if (obj === null || obj === undefined) {
        return obj;
      }
      
      // Convert Firestore FieldValue.serverTimestamp() sentinel to ISO string
      if (obj && obj._methodName === "FieldValue.serverTimestamp") {
        return new Date().toISOString();
      }
      
      // Convert Firestore Timestamp objects to ISO strings (preserve milliseconds)
      if (obj && typeof obj === "object" && obj._seconds !== undefined) {
        const seconds = typeof obj._seconds === 'number' ? obj._seconds : parseInt(obj._seconds);
        const nanoseconds = obj._nanoseconds || 0;
        // Preserve millisecond precision: seconds * 1000 + nanoseconds / 1000000
        const milliseconds = seconds * 1000 + Math.floor(nanoseconds / 1000000);
        return new Date(milliseconds).toISOString();
      }
      
      // Handle arrays
      if (Array.isArray(obj)) {
        return obj.map(item => normalizeForGCS(item));
      }
      
      // Handle objects
      if (typeof obj === "object") {
        const normalized = {};
        for (const [key, value] of Object.entries(obj)) {
          normalized[key] = normalizeForGCS(value);
        }
        return normalized;
      }
      
      // Handle ISO timestamp strings - normalize to remove milliseconds if present
      if (typeof obj === "string" && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(obj)) {
        // Keep the timestamp as-is (don't round)
        return obj;
      }
      
      return obj;
    };
    
    const gcsEntry = normalizeForGCS(auditEntry);

    await file.save(JSON.stringify(gcsEntry, null, 2), {
      metadata: {
        contentType: "application/json",
        // Custom metadata for searchability
        operation: operation,
        tripId: tripId,
        severity: auditEntry.severity || "INFO",
        timestamp: new Date().toISOString(),
        // Firestore document ID for cross-reference
        firestoreDocId: firestoreRef.id,
        // Event ID for matching Firestore and GCS entries
        eventId: auditEntry.eventId || null,
      },
    });

    logger.info(`‚úÖ GCS: Audit entry written (${fileName})`);
  } catch (error) {
    // Sanitize error message to prevent sensitive data exposure
    const errorMessage = error?.message || String(error);
    logger.error(`‚ùå Error writing audit entry: ${errorMessage}`);
    // Don't throw - we don't want to break the main operation
    // Just log the error for monitoring
  }
}

/**
 * Calculate HMAC-SHA256 signature
 * @param {string} message - The message to sign
 * @param {string} key - The secret key
 * @return {string} - Hex string of first 8 characters
 */
function calculateHMAC(message, key) {
  const hmac = crypto.createHmac("sha256", key);
  hmac.update(message);
  const fullHash = hmac.digest("hex");
  return fullHash.substring(0, 8).toLowerCase();
}

/**
 * Validate HMAC signature in trip ID
 * @param {string} tripId - Trip ID to validate
 * @return {object} - {valid: boolean, reason: string}
 */
function validateTripIdSignature(tripId) {
  // Split trip ID parts
  const parts = tripId.split("-");
  
  // Check format
  if (parts.length === 4) {
    // Legacy format (no signature) - allow for backward compatibility
    return {valid: true, reason: "legacy_format"};
  }
  
  if (parts.length !== 5) {
    return {valid: false, reason: "invalid_format"};
  }
  
  // Extract signature
  const [deviceId, destDir, date, time, signature] = parts;
  const baseTripId = `${deviceId}-${destDir}-${date}-${time}`;
  
  // Calculate expected signature
  const expectedSignature = calculateHMAC(baseTripId, HMAC_SECRET);
  
  // Compare signatures (case-insensitive)
  if (signature.toLowerCase() === expectedSignature) {
    return {valid: true, reason: "signature_valid"};
  }
  
  return {valid: false, reason: "signature_mismatch"};
}

/**
 * Validate metadata consistency
 * @param {object} metadata - _writeMetadata object
 * @return {object} - {valid: boolean, issues: string[]}
 */
function validateMetadata(metadata) {
  const issues = [];
  
  if (!metadata) {
    return {valid: false, issues: ["missing_metadata"]};
  }
  
  // Check required fields
  if (!metadata.source) issues.push("missing_source");
  if (!metadata.timestamp) issues.push("missing_timestamp");
  
  // Validate source
  if (metadata.source && !["ios_app", "web_survey"].includes(metadata.source)) {
    issues.push("invalid_source");
  }
  
  // Validate device ID format (if present)
  // Accept both full UUID (legacy) and 8-char device hash (new format)
  if (metadata.deviceId) {
    const uuidRegex = /^[A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12}$/i;
    const hashRegex = /^[A-F0-9]{8}$/i;
    const hexStringRegex = /^[a-f0-9]{16,36}$/i; // Legacy test data (16-36 hex chars)
    
    if (!uuidRegex.test(metadata.deviceId) && 
        !hashRegex.test(metadata.deviceId) && 
        !hexStringRegex.test(metadata.deviceId)) {
      issues.push("invalid_device_id_format");
    }
  }
  
  // Validate build number (if present)
  if (metadata.appBuild) {
    const buildNum = parseInt(metadata.appBuild);
    if (isNaN(buildNum) || buildNum < 1 || buildNum > 1000) {
      issues.push("invalid_build_number");
    }
  }
  
  return {valid: issues.length === 0, issues};
}

/**
 * Determine canonical source string for audit entries.
 * Prioritizes write metadata source, then survey metadata, with optional fallback.
 */
function resolveSource(writeMetadata, surveyMetadata, fallback = null) {
  if (writeMetadata && typeof writeMetadata.source === "string" && writeMetadata.source.trim() !== "") {
    return writeMetadata.source.trim();
  }
  if (surveyMetadata && typeof surveyMetadata.source === "string" && surveyMetadata.source.trim() !== "") {
    return surveyMetadata.source.trim();
  }
  return fallback;
}

/**
 * Audit Logger - Logs all tripCompletions writes
 * Triggers on document creation
 */
exports.auditLoggerCreate = onDocumentCreated("tripCompletions/{tripId}", async (event) => {
  const snapshot = event.data;
  const tripId = event.params.tripId;
  
  if (!snapshot) {
    logger.warn("No data associated with the event");
    return;
  }
  
  const data = snapshot.data();
  const source = resolveSource(data._writeMetadata, data._surveyMetadata, "firebase_console");
  
  // Create audit log entry (minimal - full data is in tripCompletions)
  // Only include fields that exist (don't default to null - Firestore omits null values)
  const auditEntry = {
    operation: "CREATE",
    collection: "tripCompletions",
    documentId: tripId,
    tripId: tripId,
    timestamp: FieldValue.serverTimestamp(),
    source: source,
    severity: "INFO",
    message: `Trip ${tripId} created`,
    eventId: event.id,
  };

  const metadata = {};
  if (data._writeMetadata !== undefined) metadata.writeMetadata = data._writeMetadata;
  if (data._surveyMetadata !== undefined) metadata.surveyMetadata = data._surveyMetadata;
  if (Object.keys(metadata).length > 0) {
    auditEntry.metadata = metadata;
  }
  
  // Only add fields if they exist (prevents Firestore from omitting them)
  if (data.destinationCode !== undefined) auditEntry.destinationCode = data.destinationCode;
  if (data.originTimezone !== undefined) auditEntry.originTimezone = data.originTimezone;
  if (data.arrivalTimeZone !== undefined) auditEntry.arrivalTimeZone = data.arrivalTimeZone;
  if (data.travelDirection !== undefined) auditEntry.travelDirection = data.travelDirection;
  
  try {
    await writeAuditEntry(auditEntry);
    logger.info(`‚úÖ Audit log created for trip ${tripId}`, {tripId, operation: "CREATE"});
  } catch (error) {
    logger.error(`‚ùå Failed to create audit log for trip ${tripId}`, {tripId, error: error.message});
  }
});

/**
 * Audit Logger - Logs all tripCompletions updates
 * Triggers on document update
 */
exports.auditLoggerUpdate = onDocumentUpdated("tripCompletions/{tripId}", async (event) => {
  const beforeSnapshot = event.data.before;
  const afterSnapshot = event.data.after;
  const tripId = event.params.tripId;
  
  if (!beforeSnapshot || !afterSnapshot) {
    logger.warn("Missing before or after snapshot");
    return;
  }
  
  const beforeData = beforeSnapshot.data();
  const afterData = afterSnapshot.data();
  const source = resolveSource(afterData._writeMetadata, afterData._surveyMetadata, "firebase_console");
  
  // Helper function to normalize values for comparison
  // Treats undefined, null, and empty string as equivalent "empty" state
  function normalizeForComparison(value) {
    if (value === undefined) return null;
    if (value === null) return null;
    if (typeof value === 'string' && value.trim() === '') return null; // Empty or whitespace-only strings
    return value;
  }
  
  // Helper function to check if two values are actually different
  function valuesAreDifferent(before, after) {
    const beforeNormalized = normalizeForComparison(before);
    const afterNormalized = normalizeForComparison(after);
    
    // If both are null (normalized), they're the same
    if (beforeNormalized === null && afterNormalized === null) return false;
    
    // If one is null and the other isn't, they're different
    if (beforeNormalized === null || afterNormalized === null) return true;
    
    // For objects/arrays, use JSON.stringify comparison
    if (typeof beforeNormalized === 'object' || typeof afterNormalized === 'object') {
      try {
        return JSON.stringify(beforeNormalized) !== JSON.stringify(afterNormalized);
      } catch (e) {
        // Fallback to string comparison if JSON.stringify fails
        return String(beforeNormalized) !== String(afterNormalized);
      }
    }
    
    // For primitives, direct comparison
    return beforeNormalized !== afterNormalized;
  }
  
  // Calculate what changed
  const changes = {};
  const allKeys = new Set([...Object.keys(beforeData), ...Object.keys(afterData)]);
  
  for (const key of allKeys) {
    if (valuesAreDifferent(beforeData[key], afterData[key])) {
      changes[key] = {
        before: beforeData[key] !== undefined ? beforeData[key] : null,
        after: afterData[key] !== undefined ? afterData[key] : null,
      };
    }
  }
  
  // Create audit log entry (store only what changed - not full snapshots)
  // Only include metadata fields that exist (prevents Firestore from omitting null values)
  const auditEntry = {
    operation: "UPDATE",
    collection: "tripCompletions",
    documentId: tripId,
    tripId: tripId,
    timestamp: FieldValue.serverTimestamp(),
    changes: changes, // Only the fields that changed
    changedFields: Object.keys(changes), // Field names for easy filtering
    source: source,
    severity: "INFO",
    message: `Trip ${tripId} updated (${Object.keys(changes).length} fields changed)`,
    eventId: event.id,
  };
  
  // Only add metadata fields if they exist
  const metadata = {};
  if (afterData._writeMetadata !== undefined) metadata.writeMetadata = afterData._writeMetadata;
  if (afterData._surveyMetadata !== undefined) metadata.surveyMetadata = afterData._surveyMetadata;
  if (Object.keys(metadata).length > 0) {
    auditEntry.metadata = metadata;
  }
  
  try {
    await writeAuditEntry(auditEntry);
    logger.info(`‚úÖ Audit log created for trip update ${tripId}`, {
      tripId,
      operation: "UPDATE",
      changedFields: Object.keys(changes),
    });
  } catch (error) {
    logger.error(`‚ùå Failed to create audit log for trip update ${tripId}`, {
      tripId,
      error: error.message,
    });
  }
});

/**
 * Audit Logger - Logs all tripCompletions deletes
 * Triggers on document deletion
 */
exports.auditLoggerDelete = onDocumentDeleted("tripCompletions/{tripId}", async (event) => {
  const snapshot = event.data;
  const tripId = event.params.tripId;
  
  if (!snapshot) {
    logger.warn("No data associated with delete event");
    return;
  }
  
  const data = snapshot.data();
  const source = resolveSource(data._writeMetadata, data._surveyMetadata, "firebase_console");
  
  // Create audit log entry for deletion
  const auditEntry = {
    operation: "DELETE",
    collection: "tripCompletions",
    documentId: tripId,
    tripId: tripId,
    timestamp: FieldValue.serverTimestamp(),
    deletedData: data,
    severity: "WARNING",
    message: `‚ö†Ô∏è Trip ${tripId} deleted from Firebase Console`,
    source: source,
    metadata: {
      writeMetadata: data._writeMetadata || null,
      surveyMetadata: data._surveyMetadata || null,
    },
    eventId: event.id,
  };
  
  try {
    await writeAuditEntry(auditEntry);
    logger.warn(`‚ö†Ô∏è Audit log created for trip deletion ${tripId}`, {tripId, operation: "DELETE"});
  } catch (error) {
    logger.error(`‚ùå Failed to create audit log for trip deletion ${tripId}`, {tripId, error: error.message});
  }
});

/**
 * HMAC Validator - Validates signatures on trip creation
 * Triggers on document creation
 */
exports.hmacValidator = onDocumentCreated("tripCompletions/{tripId}", async (event) => {
  const snapshot = event.data;
  const tripId = event.params.tripId;
  
  if (!snapshot) {
    logger.warn("No data associated with the event");
    return;
  }
  
  const data = snapshot.data();
  
  // Validate HMAC signature
  const validation = validateTripIdSignature(tripId);
  
  if (!validation.valid) {
    logger.warn(`‚ö†Ô∏è Invalid HMAC signature detected for trip ${tripId}`, {
      tripId,
      reason: validation.reason,
      source: data._writeMetadata?.source,
    });
    
    // Log to audit trail
    await writeAuditEntry({
      operation: "HMAC_VALIDATION_FAILED",
      collection: "tripCompletions",
      documentId: tripId,
      timestamp: FieldValue.serverTimestamp(),
      source: resolveSource(data._writeMetadata, data._surveyMetadata, data._writeMetadata?.source || null),
      reason: validation.reason,
      metadata: data._writeMetadata || null,
      eventId: event.id,
    });
    
    // Optional: Auto-flag or delete invalid trips
    // Uncomment to enable auto-deletion:
    // await snapshot.ref.delete();
    // logger.warn(`üóëÔ∏è Deleted trip with invalid signature: ${tripId}`);
  } else {
    logger.info(`‚úÖ HMAC signature valid for trip ${tripId}`, {
      tripId,
      reason: validation.reason,
    });
  }
});

/**
 * Metadata Validator - Checks metadata consistency
 * Triggers on document creation
 */
exports.metadataValidator = onDocumentCreated("tripCompletions/{tripId}", async (event) => {
  const snapshot = event.data;
  const tripId = event.params.tripId;
  
  if (!snapshot) {
    logger.warn("No data associated with the event");
    return;
  }
  
  const data = snapshot.data();
  const metadata = data._writeMetadata;
  
  // Validate metadata
  const validation = validateMetadata(metadata);
  
  if (!validation.valid) {
    logger.warn(`‚ö†Ô∏è Metadata validation issues for trip ${tripId}`, {
      tripId,
      issues: validation.issues,
    });
    
    // Log to audit trail
    // Only include metadata if it exists (prevents Firestore from omitting null values)
    const auditEntry = {
      operation: "METADATA_VALIDATION_FAILED",
      collection: "tripCompletions",
      documentId: tripId,
      timestamp: FieldValue.serverTimestamp(),
      source: resolveSource(metadata, data._surveyMetadata, metadata?.source || null),
      issues: validation.issues,
      eventId: event.id, // eventId links related entries from same source event
    };
    // Only add metadata if it exists (don't default to null - Firestore omits null values)
    if (metadata !== undefined && metadata !== null) {
      auditEntry.metadata = metadata;
    }
    await writeAuditEntry(auditEntry);
  } else {
    logger.info(`‚úÖ Metadata valid for trip ${tripId}`, {tripId});
  }
});

/**
 * Real-Time Trip Notification - Sends email immediately when trip is created
 * Triggers on new document in tripCompletions collection
 */
exports.realtimeTripNotification = onDocumentCreated({
  document: "tripCompletions/{tripId}",
  secrets: ["GMAIL_PASSWORD", "GMAIL_USER"],
}, async (event) => {
  const snapshot = event.data;
  const tripId = event.params.tripId;
  
  if (!snapshot) {
    logger.warn("No data associated with the event");
    return;
  }
  
  const data = snapshot.data();
  
  try {
    logger.info(`üìß Sending real-time notification for new trip: ${tripId}`);
    
    const emailBody = `New trip created:

Trip ID: ${tripId}
Destination: ${data.destinationCode || "Unknown"}
Direction: ${data.travelDirection || "Unknown"}
Points Completed: ${data.pointsCompleted || 0}/12
Timezone Count: ${data.timezonesCount ?? "Unknown"}
Survey: ${data.surveyCompleted ? "Yes" : "No"}

---
JetLagPro Research Analytics
${new Date().toLocaleString("en-US", { timeZone: "America/New_York" })}`;

    const transporter = getEmailTransporter();
    if (!transporter) {
      logger.warn("‚ö†Ô∏è Gmail transporter not initialized - skipping notification");
      return;
    }

    let gmailUser = "sbschram@gmail.com";
    try {
      gmailUser = functions.config().gmail?.user || "sbschram@gmail.com";
    } catch (e) {
      gmailUser = process.env.GMAIL_USER || "sbschram@gmail.com";
    }
    
    await transporter.sendMail({
      from: gmailUser,
      to: NOTIFICATION_EMAIL,
      subject: `JetLagPro: New Trip - ${data.destinationCode || tripId.substring(0, 8)}`,
      text: emailBody,
    });
    
    logger.info(`‚úÖ Real-time notification sent for trip ${tripId}`);
  } catch (error) {
    // Sanitize error message to prevent password exposure
    const errorMessage = error?.message || String(error);
    logger.error(`‚ùå Error sending real-time trip notification for ${tripId}: ${errorMessage}`);
  }
});

/**
 * Real-Time Survey Notification - Sends email immediately when survey is completed/edited
 * Triggers on document update in tripCompletions collection
 */
exports.realtimeSurveyNotification = onDocumentUpdated({
  document: "tripCompletions/{tripId}",
  secrets: ["GMAIL_PASSWORD", "GMAIL_USER"],
}, async (event) => {
  const beforeSnapshot = event.data.before;
  const afterSnapshot = event.data.after;
  const tripId = event.params.tripId;
  
  if (!beforeSnapshot || !afterSnapshot) {
    logger.warn("Missing before or after snapshot");
    return;
  }
  
  const beforeData = beforeSnapshot.data();
  const afterData = afterSnapshot.data();
  
  // Check if survey-related fields changed
  const changedKeys = Object.keys(afterData).filter(key => 
    afterData[key] !== beforeData[key]
  );
  
  const isSurveyUpdate = changedKeys.some(key => 
    key.includes("survey") || 
    key.includes("Post") || 
    key.includes("ageRange") ||
    key.includes("userComment")
  );
  
  if (!isSurveyUpdate) {
    // Not a survey update - skip notification
    return;
  }
  
  try {
    logger.info(`üìß Sending real-time notification for survey update: ${tripId}`);
    
    // Determine if this is new survey or edit
    const isNewSurvey = !beforeData.surveyCompleted && afterData.surveyCompleted;
    const actionType = isNewSurvey ? "completed" : "edited";
    
    const emailBody = `Survey ${actionType}:

Trip ID: ${tripId}
Destination: ${afterData.destinationCode || "Unknown"}
Direction: ${afterData.travelDirection || "Unknown"}
Action: ${actionType === "completed" ? "First-time submission" : "Survey edited/retaken"}

Changed fields: ${changedKeys.filter(k => !k.startsWith("_")).join(", ")}

---
JetLagPro Research Analytics
${new Date().toLocaleString("en-US", { timeZone: "America/New_York" })}`;

    const transporter = getEmailTransporter();
    if (!transporter) {
      logger.warn("‚ö†Ô∏è Gmail transporter not initialized - skipping notification");
      return;
    }

    let gmailUser = "sbschram@gmail.com";
    try {
      gmailUser = functions.config().gmail?.user || "sbschram@gmail.com";
    } catch (e) {
      gmailUser = process.env.GMAIL_USER || "sbschram@gmail.com";
    }
    
    await transporter.sendMail({
      from: gmailUser,
      to: NOTIFICATION_EMAIL,
      subject: `JetLagPro: Survey ${actionType === "completed" ? "Completed" : "Edited"} - ${tripId.substring(0, 8)}`,
      text: emailBody,
    });
    
    logger.info(`‚úÖ Real-time survey notification sent for trip ${tripId} (${actionType})`);
  } catch (error) {
    // Sanitize error message to prevent password exposure
    const errorMessage = error?.message || String(error);
    logger.error(`‚ùå Error sending real-time survey notification for ${tripId}: ${errorMessage}`);
  }
});
