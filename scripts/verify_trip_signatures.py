#!/usr/bin/env python3
"""
JetLagPro Trip Signature Verification Script

Verifies HMAC-SHA256 cryptographic signatures on trip records to ensure
they were generated by the authentic iOS app and have not been tampered with.

================================================================================
RESEARCH CONTEXT & PURPOSE
================================================================================

Data authenticity is critical for research validity. Starting November 8, 2025
(Build 6+), every trip record includes a cryptographic signature embedded in
the trip ID. This signature proves that:
1. The trip was submitted by a legitimate iOS device with our app installed
2. The trip ID has not been tampered with or modified
3. The data originated from an authenticated source

WHY THIS VERIFICATION MATTERS:
- Prevents data fabrication: Cannot create fake trip records without the app
- Ensures device authentication: Only legitimate iOS devices can generate valid signatures
- Detects tampering: Any modification to trip IDs invalidates the signature
- Enables independent verification: Reviewers can verify authenticity themselves
- Research validity: Confirms published results are based on authentic data

================================================================================
VERIFICATION METHODOLOGY
================================================================================

This script EXACTLY replicates the verification logic in verify.html (lines 865-955):

1. TRIP ID FORMAT DETECTION (verify.html lines 870-895):
   - UUID format (5 parts, legacy): Very old trips before any signature system
   - Legacy format (4 parts): Pre-Build 6 data without signatures (expect ~20)
   - Build 6+ format (5 parts): deviceID-dest-date-time-signature (with HMAC)

2. SIGNATURE EXTRACTION (verify.html lines 898-900):
   - Base trip ID: First 4 parts joined with '-' (deviceID-dest-date-time)
   - Provided signature: Last part (8 hex characters)

3. HMAC COMPUTATION (verify.html lines 924-925):
   - Algorithm: HMAC-SHA256
   - Input: baseTripId (deviceID-dest-date-time)
   - Secret key: Embedded in iOS app (same key used for all signatures)
   - Output: First 8 hex characters of HMAC digest (lowercase)

4. SIGNATURE VALIDATION (verify.html line 927):
   - Compares provided signature (from trip ID) with computed signature
   - Case-insensitive comparison
   - Valid: Signatures match → trip is authenticated
   - Invalid: Signatures don't match → potential tampering or fabrication

5. CATEGORIZATION (verify.html lines 975-990):
   - authenticated: Build 6+ trips with valid signatures
   - legacy: Pre-Build 6 trips without signatures (expected ~20)
   - invalid: Trips with signature mismatches (potential tampering)
   - error: Malformed trip IDs or missing trip IDs

================================================================================
INTERPRETING RESULTS
================================================================================

SUCCESS (All signatures valid or legacy):
  - All trip records are authentic
  - No evidence of tampering or fabrication
  - Legacy trips are expected (pre-HMAC implementation)

FAILURE SCENARIOS:

1. Invalid Signatures (signature_mismatch):
   - Trip ID format is correct but signature doesn't match computed value
   - Possible causes:
     * Trip ID was modified after creation (tampering)
     * Trip was fabricated without using the iOS app
     * Data corruption during storage or transmission
   - Action: Investigate immediately - compare expected vs provided signatures
   - Impact: These trips should be excluded from analysis as they cannot be verified

2. Invalid Signature Format:
   - Signature part is not 8 hex characters
   - Indicates malformed trip ID or data corruption
   - Action: Check trip ID format, verify data integrity

3. Unexpected Format:
   - Trip ID doesn't match any known format
   - Indicates data corruption or unknown format
   - Action: Investigate trip ID structure

4. Missing Trip IDs:
   - Trip record has no tripId field
   - Indicates data integrity issue
   - Action: Check data source, verify Firestore export

================================================================================
TECHNICAL DETAILS FOR REVIEWERS
================================================================================

TRIP ID FORMATS:

1. UUID Format (Legacy, very old):
   Format: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   Example: 12345678-1234-1234-1234-123456789012
   - 5 parts with specific lengths (8-4-4-4-12)
   - Created before any signature system
   - Automatically accepted as valid (legacy data)

2. Legacy Format (Pre-Build 6):
   Format: deviceID-dest-date-time
   Example: ABC12345-JFK-20251108-143022
   - 4 parts (no signature)
   - Created before November 8, 2025
   - Expected count: ~20 trips
   - Automatically accepted as valid (legacy data)

3. Build 6+ Format (With HMAC):
   Format: deviceID-dest-date-time-signature
   Example: ABC12345-JFK-20251108-143022-a1b2c3d4
   - 5 parts (last part is 8 hex character signature)
   - Created November 8, 2025 and later
   - Signature must be validated

HMAC SIGNATURE COMPUTATION:
- Algorithm: HMAC-SHA256 (RFC 2104)
- Secret key: Embedded in iOS app binary (not in this script - contact authors)
- Input message: baseTripId = "deviceID-dest-date-time"
- Output: Full HMAC-SHA256 digest (256 bits = 64 hex characters)
- Signature: First 8 hex characters of digest, converted to lowercase
- Example: Full digest "a1b2c3d4e5f6..." → signature "a1b2c3d4"

SECURITY CONSIDERATIONS:
- Secret key is embedded in iOS app (not in this script for security)
- Contact study authors to obtain key for independent verification
- Key is same for all trips (enables batch verification)
- Signature is embedded in trip ID (cannot be separated without parsing)

VERIFICATION PROCESS:
1. Parse trip ID to extract baseTripId and provided signature
2. Compute expected signature using HMAC-SHA256(baseTripId, secret_key)
3. Compare provided signature with expected signature
4. Categorize result: authenticated, legacy, invalid, or error

================================================================================
REPRODUCIBILITY & VERIFICATION
================================================================================

This script enables independent verification - reviewers can:
1. Download trip data from Firestore REST API (public read access)
2. Obtain secret key from study authors (for signature verification)
3. Run this script to verify all trip signatures
4. Confirm data authenticity without relying on study authors

The verification is deterministic:
- Same trip ID + same secret key = same signature
- Results are reproducible by any reviewer with the key
- No randomness or non-deterministic behavior

Expected Results:
- authenticated: Most trips (Build 6+)
- legacy: ~20 trips (pre-Build 6)
- invalid: 0 (any invalid signatures indicate a problem)
- error: 0 (any errors indicate data integrity issues)

================================================================================
USAGE
================================================================================

Example workflow:
  1. Download trip data:
     curl -s "https://firestore.googleapis.com/v1/projects/jetlagpro-research/databases/(default)/documents/tripCompletions?pageSize=1000" -o trips.json
  
  2. Run verification (with secret key from authors):
     python verify_trip_signatures.py --trips trips.json --secret-key YOUR_SECRET_KEY
  
  3. Review results:
     - Check for invalid signatures (should be 0)
     - Verify legacy count matches expected (~20)
     - Confirm all Build 6+ trips are authenticated

Requirements:
    - Python 3.6+
    - No external dependencies (uses only standard library)
    - Secret key (contact study authors)

Security Note:
    The secret key is required for signature verification. Contact the study
    authors to obtain the key for independent verification. The key is the same
    for all trips and is embedded in the iOS app binary.

Author: Steven Schram PhD, DC, LAc
License: MIT
Repository: https://github.com/SBSchram/jetlagpro-website
"""

import json
import hmac
import hashlib
import re
import sys
import urllib.request
from typing import Dict, List, Optional


def compute_signature_from_trip_id(trip_id: str, secret_key: str) -> str:
    """
    Compute HMAC-SHA256 signature from trip ID.
    
    EXACTLY matches verify.html line 899-925:
    - Trip IDs from Build 6+ have format: deviceID-dest-date-time-signature
    - Signature is computed from baseTripId (first 4 parts: deviceID-dest-date-time)
    - Returns first 8 hex characters of HMAC-SHA256 hash (lowercase)
    
    METHODOLOGY:
    This function replicates the iOS app's signature generation process:
    1. Extracts baseTripId (first 4 parts of trip ID)
    2. Computes HMAC-SHA256(baseTripId, secret_key)
    3. Takes first 8 hex characters of the digest
    4. Converts to lowercase
    
    This matches the iOS app's implementation exactly, ensuring that any
    signature computed here will match the signature embedded in the trip ID
    if the trip was created by a legitimate iOS device.
    
    Args:
        trip_id: Full trip identifier (deviceID-dest-date-time-signature)
        secret_key: Secret key for HMAC computation (same as in iOS app)
    
    Returns:
        str: First 8 hex characters of HMAC-SHA256 signature (lowercase), or None if trip_id has < 4 parts
    """
    parts = trip_id.split('-')
    
    # Must have at least 4 parts to compute signature
    if len(parts) < 4:
        return None
    
    # Base trip ID is first 4 parts joined with '-'
    # Matches verify.html line 899: const baseTripId = parts.slice(0, 4).join('-');
    base_trip_id = '-'.join(parts[:4])
    
    # Compute HMAC-SHA256
    # Matches verify.html line 924: const hmac = CryptoJS.HmacSHA256(baseTripId, HMAC_SECRET);
    hmac_obj = hmac.new(
        secret_key.encode('utf-8'),
        base_trip_id.encode('utf-8'),
        hashlib.sha256
    )
    
    # Get hex digest and take first 8 characters (lowercase)
    # Matches verify.html line 925: const expectedSignature = hmac.toString(CryptoJS.enc.Hex).substring(0, 8).toLowerCase();
    signature = hmac_obj.hexdigest()[:8].lower()
    
    return signature


def verify_trip_signature(trip_id: str, secret_key: str) -> Dict:
    """
    Verify the HMAC-SHA256 signature embedded in a trip ID.
    
    EXACTLY matches verify.html validateTripHMAC() line 865-955:
    - Validates trip ID format and extracts signature
    - Computes expected signature from baseTripId
    - Compares provided vs expected signature
    
    METHODOLOGY:
    This function implements the complete signature verification process:
    1. Detects trip ID format (UUID, legacy 4-part, or Build 6+ 5-part)
    2. For Build 6+ format: extracts baseTripId and provided signature
    3. Validates signature format (8 hex characters)
    4. Computes expected signature using HMAC-SHA256
    5. Compares provided vs expected (case-insensitive)
    6. Returns categorized result matching JavaScript format
    
    CATEGORIES:
    - legacy: Pre-Build 6 trips or UUID format (no signature validation)
    - authenticated: Build 6+ trips with valid signatures
    - invalid: Build 6+ trips with signature mismatches
    - error: Malformed trip IDs or missing trip IDs
    
    Args:
        trip_id: Full trip identifier (may contain embedded signature)
        secret_key: Secret key for HMAC verification (same as in iOS app)
    
    Returns:
        Dictionary with verification result matching JavaScript format:
        {
            'valid': bool,
            'reason': str,
            'category': str ('legacy', 'authenticated', 'invalid', 'error', 'unverified'),
            'tripId': str,
            'expected': str (if invalid),
            'provided': str (if invalid)
        }
    """
    if not trip_id:
        return {
            'valid': False,
            'reason': 'missing_trip_id',
            'category': 'error',
            'tripId': ''
        }
    
    parts = trip_id.split('-')
    
    # Check for UUID format (legacy, very old trips)
    # Matches verify.html line 873-884
    if len(parts) == 5 and \
       len(parts[0]) == 8 and \
       len(parts[1]) == 4 and \
       len(parts[2]) == 4 and \
       len(parts[3]) == 4 and \
       len(parts[4]) == 12:
        return {
            'valid': True,
            'reason': 'legacy_uuid_format',
            'category': 'legacy',
            'tripId': trip_id
        }
    
    # Legacy format (4 parts): Pre-Build 6 data without signatures
    # Matches verify.html line 887-894
    if len(parts) == 4:
        return {
            'valid': True,
            'reason': 'legacy_no_signature',
            'category': 'legacy',
            'tripId': trip_id
        }
    
    # Build 6+ format (5 parts): deviceID-dest-date-time-signature
    # Matches verify.html line 897-944
    if len(parts) == 5:
        base_trip_id = '-'.join(parts[:4])  # First 4 parts
        provided_signature = parts[4]  # Last part is the signature
        
        # Validate signature format (8 hex characters)
        # Matches verify.html line 903
        if not re.match(r'^[a-fA-F0-9]{8}$', provided_signature):
            return {
                'valid': False,
                'reason': 'invalid_signature_format',
                'category': 'invalid',
                'tripId': trip_id,
                'providedSignature': provided_signature
            }
        
        # Compute expected signature
        expected_signature = compute_signature_from_trip_id(trip_id, secret_key)
        
        # Compare signatures (case-insensitive)
        # Matches verify.html line 927
        if provided_signature.lower() == expected_signature.lower():
            return {
                'valid': True,
                'reason': 'valid_signature',
                'category': 'authenticated',
                'tripId': trip_id,
                'signature': provided_signature
            }
        else:
            return {
                'valid': False,
                'reason': 'signature_mismatch',
                'category': 'invalid',
                'tripId': trip_id,
                'expected': expected_signature,
                'provided': provided_signature
            }
    
    # Unexpected format
    # Matches verify.html line 947-954
    return {
        'valid': False,
        'reason': 'unexpected_format',
        'category': 'error',
        'tripId': trip_id,
        'parts': len(parts)
    }


def load_trips(trips_path: str) -> List[Dict]:
    """Load trip records from JSON file."""
    print(f"Loading trips from: {trips_path}")
    
    with open(trips_path, 'r') as f:
        data = json.load(f)
    
    # Handle Firestore REST API format
    if 'documents' in data:
        trips = []
        for doc in data['documents']:
            trip = {}
            if 'fields' in doc:
                # Extract fields from Firestore format
                for key, value in doc['fields'].items():
                    if 'stringValue' in value:
                        trip[key] = value['stringValue']
                    elif 'integerValue' in value:
                        trip[key] = int(value['integerValue'])
                    elif 'doubleValue' in value:
                        trip[key] = float(value['doubleValue'])
                    elif 'booleanValue' in value:
                        trip[key] = value['booleanValue']
                    elif 'timestampValue' in value:
                        trip[key] = value['timestampValue']
            trips.append(trip)
    elif isinstance(data, list):
        trips = data
    else:
        trips = [data]
    
    print(f"  Loaded {len(trips)} trip records")
    return trips


def verify_all_trips(trips: List[Dict], secret_key: str) -> Dict:
    """
    Verify signatures for all trips.
    
    EXACTLY matches verify.html runTripVerification() line 974-990:
    - Categorizes trips: authenticated, legacy, invalid, error
    - Uses tripId from trip record (or documentId as fallback)
    - Calls validateTripHMAC for each trip
    
    Returns:
        Report dictionary with verification results matching JavaScript format
    """
    print("\nVerifying trip signatures...")
    
    # Categories matching verify.html line 975-980
    categories = {
        'authenticated': [],  # Build 6+ with valid signatures
        'legacy': [],         # Pre-Build 6 without signatures
        'invalid': [],        # Invalid or mismatched signatures
        'error': []          # Missing trip IDs or malformed
    }
    
    for trip in trips:
        # Extract tripId - matches verify.html line 983
        trip_id = trip.get('tripId') or trip.get('documentId') or ''
        
        # Validate HMAC signature - matches verify.html line 984
        validation = verify_trip_signature(trip_id, secret_key)
        
        # Categorize - matches verify.html line 985-989
        categories[validation['category']].append({
            'tripId': trip_id,
            'documentId': trip.get('documentId') or trip.get('id') or 'unknown',
            'validation': validation
        })
    
    report = {
        'total_trips': len(trips),
        'authenticated': len(categories['authenticated']),
        'legacy': len(categories['legacy']),
        'invalid': len(categories['invalid']),
        'error': len(categories['error']),
        'categories': categories
    }
    
    return report


def print_report(report: Dict, verbose: bool = False) -> int:
    """
    Print verification report.
    
    EXACTLY matches verify.html runTripVerification() output format line 993-1029.
    
    Returns exit code: 0 if all valid, 1 if invalid signatures found.
    """
    print("\n" + "="*60)
    print("TRIP SIGNATURE VERIFICATION REPORT")
    print("="*60)
    print(f"Trip records: {report['total_trips']}")
    print("")
    print("HMAC Validation Results:")
    print(f"  Authenticated (valid signatures): {report['authenticated']}")
    print(f"  Legacy data (expect only 20) prior to HMAC: {report['legacy']}")
    print(f"  Invalid (signature mismatch): {report['invalid']}")
    print(f"  Error (malformed trip IDs): {report['error']}")
    print("="*60)
    
    # Interpretation section
    print("\nINTERPRETING RESULTS:")
    print("  All signatures valid – All trip records were submitted by legitimate iOS devices")
    print("  Legacy trips (no signature) – Expected for 20 early records before HMAC was implemented")
    print("  Invalid signatures – Potential tampering or unauthorized submissions; investigate immediately")
    print("  Missing trip IDs – Data integrity issue; investigate immediately")
    print("")
    
    # Check for invalid signatures - matches verify.html line 1003
    if report['invalid'] == 0 and report['error'] == 0:
        print("✓ VERIFICATION PASSED")
        print("Trip verification complete: all signatures are valid or legacy.")
        return 0
    else:
        print("✗ VERIFICATION FAILED")
        print("INVALID SIGNATURES FOUND:\n")
        
        # Show invalid signatures - matches verify.html line 1009-1018
        if report['invalid'] > 0:
            print(f"Invalid Signatures ({report['invalid']}):")
            for item in report['categories']['invalid']:
                print(f"  - {item['tripId']}")
                validation = item['validation']
                if validation.get('expected') and validation.get('provided'):
                    print(f"    Expected: {validation['expected']}")
                    print(f"    Provided: {validation['provided']}")
            print("")
        
        # Show errors - matches verify.html line 1021-1026
        if report['error'] > 0:
            print(f"Malformed Trip IDs ({report['error']}):")
            for item in report['categories']['error']:
                trip_id = item.get('tripId') or 'missing'
                reason = item['validation'].get('reason', 'unknown')
                print(f"  - {trip_id} ({reason})")
        
        return 1


def download_firestore_entries(collection='tripCompletions', output_file='firestore-trips.json') -> str:
    """
    Download Firestore collection data via REST API with automatic pagination.
    Returns the path to the downloaded file.
    """
    print(f"Downloading {collection} from Firestore...")
    
    base_url = f'https://firestore.googleapis.com/v1/projects/jetlagpro-research/databases/(default)/documents/{collection}?pageSize=1000'
    all_docs = []
    token = None
    
    while True:
        url = base_url + (f'&pageToken={token}' if token else '')
        with urllib.request.urlopen(url) as response:
            data = json.loads(response.read())
            docs = data.get('documents', [])
            all_docs.extend(docs)
            print(f"  Downloaded {len(all_docs)} documents...", end='\r')
            
            token = data.get('nextPageToken')
            if not token:
                break
    
    with open(output_file, 'w') as f:
        json.dump({'documents': all_docs}, f, indent=2)
    
    print(f"\n  Saved {len(all_docs)} documents to {output_file}")
    return output_file


def main():
    """Main verification workflow."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Verify JetLagPro trip cryptographic signatures',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Example usage:
  # Download trip data from Firestore
  curl -s "https://firestore.googleapis.com/v1/projects/jetlagpro-research/databases/(default)/documents/trips?pageSize=1000" -o trips.json
  
  # Verify signatures
  python verify_trip_signatures.py --trips trips.json --secret-key YOUR_SECRET_KEY
  
  # Verbose output
  python verify_trip_signatures.py --trips trips.json --secret-key YOUR_SECRET_KEY --verbose

Security Note:
  The secret key is required for verification. Contact the study authors
  if you need access to the key for independent verification.
        """
    )
    
    parser.add_argument(
        '--trips',
        required=False,
        help='Path to trips JSON file (optional, auto-downloads if not provided)'
    )
    parser.add_argument(
        '--secret-key',
        required=False,
        default='7f3a9d8b2c4e1f6a5d8b3c9e7f2a4d6b8c1e3f5a7d9b2c4e6f8a1d3b5c7e9f2a',
        help='Secret key for HMAC verification (defaults to public key for research transparency)'
    )
    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Show detailed signature information'
    )
    
    args = parser.parse_args()
    
    # Auto-download trip data if not provided
    if not args.trips:
        print("Note: Trips file not provided, downloading automatically...")
        print()
        args.trips = download_firestore_entries('tripCompletions', 'firestore-trips.json')
        print()
    
    # Load trips
    try:
        trips = load_trips(args.trips)
    except FileNotFoundError:
        print(f"ERROR: Trips file not found: {args.trips}")
        return 1
    except json.JSONDecodeError as e:
        print(f"ERROR: Invalid JSON in trips file: {e}")
        return 1
    except Exception as e:
        print(f"ERROR: Failed to load trips: {e}")
        return 1
    
    # Verify all trips
    report = verify_all_trips(trips, args.secret_key)
    
    # Print report and exit
    exit_code = print_report(report, verbose=args.verbose)
    return exit_code


if __name__ == '__main__':
    sys.exit(main())

