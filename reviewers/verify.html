<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verify Audit Trail</title>
    <script src="load-reviewer-head.js?v=20251112-01"></script>
    <link rel="stylesheet" href="assets/css/reviewers.css?v=20251112-02">
    <style>
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px 20px 20px 40px;
        }
        .reviewer-nav {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e7eb;
            font-size: 0.9rem;
            text-align: center;
        }
        .reviewer-nav a {
            color: #374151;
            text-decoration: none;
            margin-right: 8px;
        }
        .reviewer-nav a:hover {
            color: #1f2937;
            text-decoration: underline;
        }
        .reviewer-nav a.active {
            color: #1f2937;
            font-weight: 600;
        }
        .reviewer-nav span {
            color: #d1d5db;
            margin: 0 8px;
        }
        .header {
            padding: 0;
            margin-bottom: 15px;
            text-align: center;
        }
        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 5px 0;
        }
        .header p {
            font-size: 0.95rem;
            color: #6b7280;
            margin: 0;
        }
        .section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e5e7eb;
        }
        .section:last-child {
            border-bottom: none;
        }
        .section h2 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 10px 0;
        }
        .section p {
            color: #374151;
            line-height: 1.5;
            margin: 0 0 10px 0;
        }
        .code-block {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            overflow-x: auto;
            position: relative;
        }
        .code-block code {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #1f2937;
            white-space: pre;
            display: block;
        }
        .copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .copy-button:hover {
            opacity: 1;
            background: #f3f4f6;
        }
        .copy-button svg {
            width: 14px;
            height: 14px;
            stroke: #374151;
            fill: none;
            stroke-width: 1.5;
        }
        .copy-button.copied {
            opacity: 1;
            background: #d1fae5;
            border-color: #10b981;
        }
        .copy-button.copied svg {
            stroke: #10b981;
        }
        .example-output {
            background: #f0f9ff;
            border-left: 3px solid #3b82f6;
            padding: 12px 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #1e40af;
        }
        .note {
            background: #f9fafb;
            border-left: 2px solid #d1d5db;
            padding: 10px 12px;
            margin: 10px 0;
            font-size: 0.9rem;
            color: #374151;
        }
        code {
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
            color: #1f2937;
        }
        .verify-button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.3s ease;
            margin-right: 10px;
        }
        .source-button {
            background: #6b7280;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: background 0.3s ease;
        }
        .source-button:hover {
            background: #4b5563;
        }
        .verify-button:hover {
            background: #2563eb;
        }
        .verify-button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .verification-results {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        .verification-results.success {
            background: #f0fdf4;
            border-color: #86efac;
            color: #166534;
        }
        .verification-results.error {
            background: #fef2f2;
            border-color: #fecaca;
            color: #991b1b;
        }
        .verification-results.warning {
            background: #fef3c7;
            border-color: #fde68a;
            color: #92400e;
        }
        .verification-results pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
    <!-- CryptoJS for HMAC-SHA256 validation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="../assets/js/firebase-service.js?v=20251112-05"></script>
    <script>
        function copyCode(button) {
            const codeBlock = button.closest('.code-block');
            const codeElement = codeBlock.querySelector('code');
            const text = codeElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                // Visual feedback
                button.classList.add('copied');
                const originalTitle = button.getAttribute('title');
                button.setAttribute('title', 'Copied!');
                
                setTimeout(() => {
                    button.classList.remove('copied');
                    button.setAttribute('title', originalTitle);
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback: select text
                const range = document.createRange();
                range.selectNode(codeElement);
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(range);
            });
        }
        
        async function runVerification() {
            const btn = document.getElementById('verifyBtn');
            const resultsDiv = document.getElementById('verificationResults');
            
            btn.disabled = true;
            btn.textContent = 'Verifying...';
            resultsDiv.style.display = 'block';
            resultsDiv.className = 'verification-results';
            resultsDiv.innerHTML = '<pre>Fetching Firestore audit data...</pre>';
            
            try {
                // Step 1: Fetch Firestore audit entries
                const firebaseService = new FirebaseService();
                const firestoreEntriesRaw = await firebaseService.getAuditLog(10000);
                
                // Store raw entries for inspection, then normalize
                const firestoreEntries = firestoreEntriesRaw.map(entry => {
                    // Store raw entry BEFORE normalization (deep copy)
                    const rawEntry = JSON.parse(JSON.stringify(entry));
                    const normalized = normalizeEntry(entry);
                    normalized._raw = rawEntry;
                    return normalized;
                });
                
                resultsDiv.innerHTML = `<pre>Firestore entries: ${firestoreEntries.length}\nFetching GCS archive...</pre>`;
                
                // Step 2: Fetch GCS audit entries
                // Note: GCS bucket needs to be publicly readable for this to work
                const gcsEntries = await fetchGCSEntries();
                
                if (!gcsEntries || gcsEntries.length === 0) {
                    resultsDiv.className = 'verification-results warning';
                    resultsDiv.innerHTML = `<pre>Firestore entries: ${firestoreEntries.length}
GCS entries: Unable to access (bucket not publicly readable)

The GCS bucket needs to be made publicly readable for web-based verification.

Option 1: Make bucket public (recommended)
Run this command to enable public read access:
  gsutil iam ch allUsers:objectViewer gs://jetlagpro-audit-logs

Option 2: Manual verification
1. Download Firestore data using the curl command above
2. Download GCS archive using gsutil command above
3. Run the verification script locally</pre>`;
                    btn.disabled = false;
                    btn.textContent = 'Run Verification';
                    return;
                }
                
                resultsDiv.innerHTML = `<pre>Firestore entries: ${firestoreEntries.length}
GCS entries: ${gcsEntries.length}
Comparing entries...</pre>`;
                
                // Step 3: Compare entries
                const comparison = compareEntries(firestoreEntries, gcsEntries);
                
                // Step 4: Display results
                let output = `Firestore entries: ${firestoreEntries.length}
GCS entries:       ${gcsEntries.length}
Matched:           ${comparison.matched}
Discrepancies:     ${comparison.discrepancies}

`;
                
                if (comparison.discrepancies === 0) {
                    output += 'Audit verification complete: all records match.';
                    resultsDiv.className = 'verification-results success';
                } else {
                    output += 'DISCREPANCIES FOUND:\n\n';
                    
                    comparison.missingInFirestore.forEach(tripId => {
                        output += `Missing in Firestore: ${tripId}\n`;
                    });
                    comparison.missingInGCS.forEach(tripId => {
                        output += `Missing in GCS: ${tripId}\n`;
                    });
                    comparison.mismatched.forEach(item => {
                        output += `Mismatch: ${item.tripId} (${item.reason})\n`;
                        if (item.details && item.details.length > 0) {
                            item.details.forEach(detail => {
                                output += `  - ${detail}\n`;
                            });
                        }
                        // Add raw data inspection
                        output += `\n=== RAW DATA INSPECTION ===\n`;
                        output += `\nFIRESTORE RAW (first 2000 chars):\n`;
                        output += JSON.stringify(item.rawFirestore, null, 2).substring(0, 2000) + '\n';
                        output += `\nGCS RAW (first 2000 chars):\n`;
                        output += JSON.stringify(item.rawGCS, null, 2).substring(0, 2000) + '\n';
                        output += `\nFIRESTORE NORMALIZED (first 2000 chars):\n`;
                        output += JSON.stringify(item.normalizedFirestore, null, 2).substring(0, 2000) + '\n';
                        output += `\nGCS NORMALIZED (first 2000 chars):\n`;
                        output += JSON.stringify(item.normalizedGCS, null, 2).substring(0, 2000) + '\n';
                        output += `\n=== END INSPECTION ===\n\n`;
                    });
                    resultsDiv.className = 'verification-results error';
                }
                
                resultsDiv.innerHTML = `<pre>${output}</pre>`;
                
            } catch (error) {
                resultsDiv.className = 'verification-results error';
                resultsDiv.innerHTML = `<pre>Error: ${error.message}\n\nPlease use the manual verification steps above.</pre>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Run Verification';
            }
        }
        
        async function fetchGCSEntries() {
            try {
                // Try to fetch the GCS bucket listing using JSON API
                // Note: Bucket must be publicly readable
                const listUrl = 'https://storage.googleapis.com/storage/v1/b/jetlagpro-audit-logs/o?prefix=audit-logs/&maxResults=10000';
                console.log('Fetching GCS bucket listing from:', listUrl);
                
                const response = await fetch(listUrl, {
                    cache: 'no-store',
                    method: 'GET'
                });
                
                console.log('GCS API response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('GCS API error response:', errorText);
                    
                    if (response.status === 403) {
                        console.warn('GCS bucket not publicly readable (403 Forbidden)');
                    } else if (response.status === 404) {
                        console.warn('GCS bucket not found (404 Not Found)');
                    } else {
                        console.warn(`GCS API error: ${response.status} ${response.statusText}`);
                    }
                    return null;
                }
                
                const data = await response.json();
                console.log('GCS API returned', data.items?.length || 0, 'items');
                const files = data.items || [];
                
                if (files.length === 0) {
                    console.warn('GCS bucket is accessible but contains no files in audit-logs/ prefix');
                    return [];
                }
                
                // Fetch each JSON file and parse (limit to reasonable number for performance)
                const entries = [];
                const maxFiles = 1000; // Limit to prevent timeout
                const jsonFiles = files.filter(f => f.name.endsWith('.json'));
                const filesToFetch = jsonFiles.slice(0, maxFiles);
                
                console.log(`Fetching ${filesToFetch.length} JSON files from GCS...`);
                
                for (const file of filesToFetch) {
                    try {
                        // Use the mediaLink or construct direct URL
                        const fileUrl = file.mediaLink || `https://storage.googleapis.com/jetlagpro-audit-logs/${file.name}`;
                        const fileResponse = await fetch(fileUrl, {
                            cache: 'no-store'
                        });
                        
                        if (fileResponse.ok) {
                            const entry = await fileResponse.json();
                            // Store raw entry for inspection
                            const rawEntry = JSON.parse(JSON.stringify(entry));
                            // GCS entries are already in plain JSON, but normalize to ensure consistency
                            const normalized = normalizeEntry(entry);
                            normalized._raw = rawEntry;
                            entries.push(normalized);
                        } else {
                            console.warn(`Failed to fetch ${file.name}: ${fileResponse.status} ${fileResponse.statusText}`);
                        }
                    } catch (e) {
                        console.warn(`Error fetching ${file.name}:`, e);
                    }
                }
                
                console.log(`Successfully fetched ${entries.length} audit entries from GCS`);
                
                if (jsonFiles.length > maxFiles) {
                    console.warn(`Only fetched first ${maxFiles} of ${jsonFiles.length} JSON files`);
                }
                
                return entries;
            } catch (error) {
                console.error('GCS fetch failed:', error);
                return null;
            }
        }
        
        function compareEntries(firestoreEntries, gcsEntries) {
            const matched = 0;
            const discrepancies = 0;
            const missingInFirestore = [];
            const missingInGCS = [];
            const mismatched = [];
            
            // Known pre-deployment entries: These 4 audit entries were created before the 
            // immutable GCS archive was deployed (2025-11-11). They exist only in Firestore
            // and are expected to be missing from GCS. We filter them out for verification
            // to avoid false positives. This list is hardcoded for transparency - any future
            // missing entries would indicate a real problem.
            const preDeploymentEventIds = new Set([
                '3479ae2f-5a3f-46ef-9439-f7ca2984337d',
                'dcd41966-3520-486e-93cc-0d50d76e1ac5',
                '1f54b779-aff3-4cd7-b667-ecfdfc898a47',
                '4253d2be-9d13-466f-b535-f55ade5b5dec'
            ]);
            
            // Create maps for quick lookup using eventId (unique identifier for each audit event)
            // Also store raw entries for inspection
            const firestoreMap = new Map();
            const firestoreRawMap = new Map();
            firestoreEntries.forEach(entry => {
                // Use eventId as the key (unique per audit event)
                // Fallback to operation-tripId if eventId is missing
                const eventId = entry.eventId || entry._raw?.eventId;
                const tripId = entry.tripId || entry.documentId || '';
                const operation = entry.operation || 'UNKNOWN';
                const key = eventId || `${operation}-${tripId}`;
                
                // Skip pre-deployment entries - they're expected to be missing from GCS
                if (preDeploymentEventIds.has(key)) {
                    return;
                }
                
                firestoreMap.set(key, entry);
                // Store raw entry if available
                if (entry._raw) {
                    firestoreRawMap.set(key, entry._raw);
                }
            });
            
            const gcsMap = new Map();
            const gcsRawMap = new Map();
            gcsEntries.forEach(entry => {
                // Use eventId as the key (unique per audit event)
                // Fallback to operation-tripId if eventId is missing
                const eventId = entry.eventId || entry._raw?.eventId;
                const tripId = entry.tripId || entry.documentId || '';
                const operation = entry.operation || 'UNKNOWN';
                const key = eventId || `${operation}-${tripId}`;
                
                // Skip pre-deployment entries (they shouldn't be in GCS, but filter just in case)
                if (preDeploymentEventIds.has(key)) {
                    return;
                }
                
                gcsMap.set(key, entry);
                // Store raw entry if available
                if (entry._raw) {
                    gcsRawMap.set(key, entry._raw);
                }
            });
            
            // Find matches and discrepancies
            let matchedCount = 0;
            const allKeys = new Set([...firestoreMap.keys(), ...gcsMap.keys()]);
            
            allKeys.forEach(key => {
                const firestoreEntry = firestoreMap.get(key);
                const gcsEntry = gcsMap.get(key);
                
                if (!firestoreEntry) {
                    missingInFirestore.push(key);
                } else if (!gcsEntry) {
                    missingInGCS.push(key);
                } else {
                    // Compare normalized entries
                    const firestoreHash = hashEntry(firestoreEntry);
                    const gcsHash = hashEntry(gcsEntry);
                    
                    if (firestoreHash === gcsHash) {
                        matchedCount++;
                    } else {
                        // For debugging, show what fields differ
                        const firestoreNorm = normalizeEntry(firestoreEntry);
                        const gcsNorm = normalizeEntry(gcsEntry);
                        const diffFields = [];
                        const diffDetails = [];
                        
                        // Store raw entries for inspection (before normalization)
                        const rawFirestore = firestoreRawMap.get(key) || JSON.parse(JSON.stringify(firestoreEntry));
                        const rawGCS = gcsRawMap.get(key) || JSON.parse(JSON.stringify(gcsEntry));
                        
                        const allKeys = new Set([...Object.keys(firestoreNorm), ...Object.keys(gcsNorm)]);
                        for (const k of allKeys) {
                            const fsVal = firestoreNorm[k];
                            const gcsVal = gcsNorm[k];
                            const fsStr = JSON.stringify(fsVal);
                            const gcsStr = JSON.stringify(gcsVal);
                            
                            if (fsStr !== gcsStr) {
                                diffFields.push(k);
                                // For arrays, show length difference
                                if (Array.isArray(fsVal) && Array.isArray(gcsVal)) {
                                    diffDetails.push(`${k}: lengths ${fsVal.length} vs ${gcsVal.length}`);
                                } else if (typeof fsVal === 'object' && typeof gcsVal === 'object') {
                                    // For objects, show key differences
                                    const fsKeys = Object.keys(fsVal || {}).sort();
                                    const gcsKeys = Object.keys(gcsVal || {}).sort();
                                    if (fsKeys.join(',') !== gcsKeys.join(',')) {
                                        diffDetails.push(`${k}: keys differ`);
                                    } else {
                                        diffDetails.push(`${k}: values differ`);
                                    }
                                } else {
                                    diffDetails.push(`${k}: ${typeof fsVal} vs ${typeof gcsVal}`);
                                }
                            }
                        }
                        
                        mismatched.push({
                            tripId: key,
                            reason: diffFields.length > 0 
                                ? `Fields differ: ${diffFields.slice(0, 5).join(', ')}` 
                                : 'Content mismatch',
                            details: diffDetails.slice(0, 3),
                            rawFirestore: rawFirestore,
                            rawGCS: rawGCS,
                            normalizedFirestore: firestoreNorm,
                            normalizedGCS: gcsNorm
                        });
                    }
                }
            });
            
            return {
                matched: matchedCount,
                discrepancies: missingInFirestore.length + missingInGCS.length + mismatched.length,
                missingInFirestore: missingInFirestore.slice(0, 10), // Limit to first 10
                missingInGCS: missingInGCS.slice(0, 10),
                mismatched: mismatched.slice(0, 10)
            };
        }
        
        function normalizeEntry(entry) {
            // Normalize an entry for comparison by:
            // 1. Converting Firestore REST API format to plain values
            // 2. Removing Firestore-specific document metadata
            // 3. Sorting nested object keys for consistent comparison
            // 4. Normalizing timestamps to ISO strings
            // 5. Handling missing fields (set to null for consistent comparison)
            const normalized = {};
            
            // Fields to skip (Firestore document metadata, not part of audit data)
            // Note: 'eventId' is part of the audit entry, not Firestore metadata, so we keep it
            // Skip '_raw' as it's a duplicate of the top-level fields for debugging
            const skipFields = new Set(['name', 'createTime', 'updateTime', 'id', '_raw']);
            
            // Get all possible keys from both Firestore and GCS entries
            // For now, we'll just use the keys from this entry
            const keys = Object.keys(entry).sort();
            
            for (const key of keys) {
                // Skip Firestore document metadata
                if (skipFields.has(key)) {
                    continue;
                }
                
                let value = entry[key];
                
                // Convert Firestore REST API format to plain values
                value = extractFirestoreValue(value);
                
                // Special handling for source field - ensure it's always a string
                if (key === 'source') {
                    if (value && typeof value === 'object') {
                        // If it's still an object after extraction, try to extract again
                        value = extractFirestoreValue(value);
                    }
                    if (value && typeof value !== 'string') {
                        // Convert to string if not already
                        value = String(value);
                    }
                    if (!value) {
                        value = null;
                    }
                }
                
                // Normalize timestamp field specifically (and any field that looks like a timestamp)
                if (key === 'timestamp' || key.includes('Time') || key.includes('At')) {
                    value = normalizeTimestamp(value);
                }
                
                // Recursively sort nested object keys for consistent comparison
                if (value && typeof value === 'object' && !Array.isArray(value)) {
                    value = sortObjectKeys(value);
                }
                
                normalized[key] = value;
            }
            
            // Ensure critical fields exist (set to null if missing for consistent comparison)
            // This handles cases where Firestore entries were created before we added these fields
            // Also normalize source to always be a string (not an object)
            if (!('source' in normalized)) {
                normalized.source = null;
            } else if (normalized.source && typeof normalized.source === 'object') {
                // If source is an object (from Firestore REST API), extract the string value
                normalized.source = extractFirestoreValue(normalized.source);
            } else if (normalized.source && typeof normalized.source !== 'string') {
                // Convert to string if it's not already
                normalized.source = String(normalized.source);
            }
            
            if (!('changedFields' in normalized)) {
                normalized.changedFields = null;
            } else if (normalized.changedFields === null) {
                normalized.changedFields = null;
            } else if (!Array.isArray(normalized.changedFields)) {
                // Ensure changedFields is an array (convert if needed)
                normalized.changedFields = [];
            } else {
                // Sort array for consistent comparison
                normalized.changedFields = [...normalized.changedFields].sort();
            }
            
            if (!('changes' in normalized)) {
                normalized.changes = null;
            } else if (normalized.changes && typeof normalized.changes !== 'object') {
                // Ensure changes is an object
                normalized.changes = null;
            }
            
            if (!('deletedData' in normalized)) {
                normalized.deletedData = null;
            }
            
            // Normalize metadata structure: ensure surveyMetadata exists for CREATE entries
            // GCS explicitly adds surveyMetadata: null for CREATE entries, but Firestore doesn't store it
            if (normalized.operation === 'CREATE' && normalized.metadata) {
                if (!('surveyMetadata' in normalized.metadata)) {
                    normalized.metadata.surveyMetadata = null;
                }
            }
            
            // Normalize timestamp strings to remove millisecond precision for comparison
            // This handles the fact that GCS might round timestamps differently than Firestore
            const normalizeTimestampString = (str) => {
                if (typeof str !== 'string') return str;
                // Match ISO timestamp with optional milliseconds: 2025-11-12T01:49:14.942Z
                // Pattern: YYYY-MM-DDTHH:mm:ss(.sss)?Z?
                const match = str.match(/^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})(\.\d{1,3})?(Z)?$/);
                if (match) {
                    // Round to seconds: remove milliseconds, keep Z if present
                    return match[1] + (match[3] ? 'Z' : '');
                }
                return str;
            };
            
            // Recursively normalize all timestamp strings in the normalized object
            const normalizeTimestampsInObject = (obj) => {
                if (obj === null || obj === undefined) return obj;
                if (typeof obj === 'string') {
                    return normalizeTimestampString(obj);
                }
                if (Array.isArray(obj)) {
                    return obj.map(item => normalizeTimestampsInObject(item));
                }
                if (typeof obj === 'object') {
                    const result = {};
                    for (const [key, value] of Object.entries(obj)) {
                        // Special handling for timestamp fields
                        if (key === 'timestamp' || key.includes('Time') || key.includes('At')) {
                            result[key] = normalizeTimestampsInObject(value);
                        } else {
                            result[key] = normalizeTimestampsInObject(value);
                        }
                    }
                    return result;
                }
                return obj;
            };
            
            // Apply timestamp normalization
            return normalizeTimestampsInObject(normalized);
        }
        
        function sortObjectKeys(obj) {
            // Recursively sort all object keys for consistent comparison
            // Also normalize any timestamp values found in nested structures
            if (obj === null || typeof obj !== 'object') {
                // Check if it's a timestamp string
                if (typeof obj === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(obj)) {
                    return normalizeTimestamp(obj);
                }
                return obj;
            }
            
            if (Array.isArray(obj)) {
                return obj.map(item => sortObjectKeys(item));
            }
            
            const sorted = {};
            const keys = Object.keys(obj).sort();
            for (const key of keys) {
                let value = obj[key];
                
                // Normalize timestamp fields in nested objects
                if (key === 'timestamp' || key.includes('Time') || key.includes('At')) {
                    value = normalizeTimestamp(value);
                }
                
                if (value && typeof value === 'object' && !Array.isArray(value)) {
                    sorted[key] = sortObjectKeys(value);
                } else if (Array.isArray(value)) {
                    sorted[key] = value.map(item => sortObjectKeys(item));
                } else {
                    sorted[key] = value;
                }
            }
            return sorted;
        }
        
        function normalizeTimestamp(value) {
            // Normalize any timestamp value to ISO string
            if (!value) return value;
            
            if (typeof value === 'string') {
                try {
                    const date = new Date(value);
                    if (!isNaN(date.getTime())) {
                        return date.toISOString();
                    }
                } catch (e) {
                    // If parsing fails, return as-is
                }
                return value;
            }
            
            if (typeof value === 'object') {
                // Firestore Timestamp object with _seconds
                if (value._seconds !== undefined) {
                    const seconds = typeof value._seconds === 'number' ? value._seconds : parseInt(value._seconds);
                    return new Date(seconds * 1000).toISOString();
                }
            }
            
            return value;
        }
        
        function extractFirestoreValue(value) {
            // Handle Firestore REST API value types
            if (value === null || value === undefined) {
                return null;
            }
            
            // If it's not an object, check if it's a timestamp string
            if (typeof value !== 'object') {
                // Check if it looks like a timestamp string
                if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value)) {
                    return normalizeTimestamp(value);
                }
                return value;
            }
            
            // Handle Firestore value wrappers (check these first before recursing)
            if (value.timestampValue !== undefined) {
                return normalizeTimestamp(value.timestampValue);
            }
            if (value.stringValue !== undefined) {
                return value.stringValue;
            }
            if (value.integerValue !== undefined) {
                return parseInt(value.integerValue);
            }
            if (value.doubleValue !== undefined) {
                return parseFloat(value.doubleValue);
            }
            if (value.booleanValue !== undefined) {
                return value.booleanValue === 'true' || value.booleanValue === true;
            }
            if (value.nullValue !== undefined) {
                return null;
            }
            if (value.arrayValue && value.arrayValue.values) {
                return value.arrayValue.values.map(v => extractFirestoreValue(v));
            }
            if (value.mapValue && value.mapValue.fields) {
                // Recursively extract nested map
                const nested = {};
                for (const [k, v] of Object.entries(value.mapValue.fields)) {
                    nested[k] = extractFirestoreValue(v);
                }
                return nested;
            }
            
            // Handle Firestore Timestamp objects (from Admin SDK, not REST API)
            if (value._seconds !== undefined) {
                return normalizeTimestamp(value);
            }
            
            // If it's a plain array, recurse
            if (Array.isArray(value)) {
                return value.map(v => extractFirestoreValue(v));
            }
            
            // Plain object - recurse on all values to extract any nested Firestore values
            const result = {};
            for (const [k, v] of Object.entries(value)) {
                result[k] = extractFirestoreValue(v);
            }
            return result;
        }
        
        function hashEntry(entry) {
            // Normalize the entry and create a hash
            const normalized = normalizeEntry(entry);
            // Use JSON.stringify with sorted keys for consistent hashing
            return JSON.stringify(normalized, Object.keys(normalized).sort());
        }
        
        // HMAC-SHA256 secret key (same as in iOS app and trip-validator.js)
        const HMAC_SECRET = '7f3a9d8b2c4e1f6a5d8b3c9e7f2a4d6b8c1e3f5a7d9b2c4e6f8a1d3b5c7e9f2a';
        
        /**
         * Validates HMAC-SHA256 signature on a trip ID
         * Trip IDs from Build 6+ have format: deviceID-dest-date-time-signature
         */
        function validateTripHMAC(tripId) {
            if (!tripId) {
                return { valid: false, reason: 'missing_trip_id', category: 'error' };
            }
            
            const parts = tripId.split('-');
            
            // Check for UUID format (legacy, very old trips)
            if (parts.length === 5 && 
                parts[0].length === 8 && 
                parts[1].length === 4 && 
                parts[2].length === 4 && 
                parts[3].length === 4 && 
                parts[4].length === 12) {
                return { 
                    valid: true, 
                    reason: 'legacy_uuid_format', 
                    category: 'legacy',
                    tripId: tripId
                };
            }
            
            // Legacy format (4 parts): Pre-Build 6 data without signatures
            if (parts.length === 4) {
                return { 
                    valid: true, 
                    reason: 'legacy_no_signature', 
                    category: 'legacy',
                    tripId: tripId
                };
            }
            
            // November 8, 2025 and later format (5 parts): deviceID-dest-date-time-signature
            if (parts.length === 5) {
                const baseTripId = parts.slice(0, 4).join('-');
                const providedSignature = parts[4];
                
                // Validate signature format (8 hex characters)
                if (!/^[a-fA-F0-9]{8}$/.test(providedSignature)) {
                    return { 
                        valid: false, 
                        reason: 'invalid_signature_format', 
                        category: 'invalid',
                        tripId: tripId,
                        providedSignature: providedSignature
                    };
                }
                
                // Check if CryptoJS is available
                if (typeof CryptoJS === 'undefined') {
                    return { 
                        valid: true, // Assume valid if we can't verify
                        reason: 'crypto_unavailable', 
                        category: 'unverified',
                        tripId: tripId
                    };
                }
                
                // Compute expected signature
                const hmac = CryptoJS.HmacSHA256(baseTripId, HMAC_SECRET);
                const expectedSignature = hmac.toString(CryptoJS.enc.Hex).substring(0, 8).toLowerCase();
                
                if (providedSignature.toLowerCase() === expectedSignature) {
                    return { 
                        valid: true, 
                        reason: 'valid_signature', 
                        category: 'authenticated',
                        tripId: tripId,
                        signature: providedSignature
                    };
                } else {
                    return { 
                        valid: false, 
                        reason: 'signature_mismatch', 
                        category: 'invalid',
                        tripId: tripId,
                        expected: expectedSignature,
                        provided: providedSignature
                    };
                }
            }
            
            // Unexpected format
            return { 
                valid: false, 
                reason: 'unexpected_format', 
                category: 'error',
                tripId: tripId,
                parts: parts.length
            };
        }
        
        async function runTripVerification() {
            const btn = document.getElementById('verifyTripBtn');
            const resultsDiv = document.getElementById('tripVerificationResults');
            
            btn.disabled = true;
            btn.textContent = 'Verifying...';
            resultsDiv.style.display = 'block';
            resultsDiv.className = 'verification-results';
            resultsDiv.innerHTML = '<pre>Fetching Firestore trip data...</pre>';
            
            try {
                // Step 1: Fetch Firestore trip records
                const firebaseService = new FirebaseService();
                const trips = await firebaseService.getTripCompletions();
                
                resultsDiv.innerHTML = `<pre>Trip records: ${trips.length}\nValidating HMAC signatures...</pre>`;
                
                // Step 2: Validate HMAC signatures
                const categories = {
                    authenticated: [],  // November 8, 2025 and later with valid signatures
                    legacy: [],         // Before November 8, 2025 without signatures
                    invalid: [],        // Invalid or mismatched signatures
                    error: []          // Missing trip IDs or malformed
                };
                
                trips.forEach(trip => {
                    const tripId = trip.tripId || trip.documentId || '';
                    const validation = validateTripHMAC(tripId);
                    categories[validation.category].push({
                        tripId: tripId,
                        documentId: trip.documentId || trip.id || 'unknown',
                        validation: validation
                    });
                });
                
                // Step 3: Display results
                let output = `Trip records: ${trips.length}

HMAC Validation Results:
  Authenticated (valid signatures): ${categories.authenticated.length}
  Legacy data (expect only 20) prior to HMAC: ${categories.legacy.length}
  Invalid (signature mismatch): ${categories.invalid.length}
  Error (malformed trip IDs): ${categories.error.length}

`;
                
                if (categories.invalid.length === 0 && categories.error.length === 0) {
                    output += 'Trip verification complete: all signatures are valid or legacy.';
                    resultsDiv.className = 'verification-results success';
                } else {
                    output += 'INVALID SIGNATURES FOUND:\n\n';
                    
                    if (categories.invalid.length > 0) {
                        output += `Invalid Signatures (${categories.invalid.length}):\n`;
                        categories.invalid.forEach(item => {
                            output += `  - ${item.tripId}\n`;
                            if (item.validation.expected && item.validation.provided) {
                                output += `    Expected: ${item.validation.expected}\n`;
                                output += `    Provided: ${item.validation.provided}\n`;
                            }
                        });
                        output += '\n';
                    }
                    
                    if (categories.error.length > 0) {
                        output += `Malformed Trip IDs (${categories.error.length}):\n`;
                        categories.error.forEach(item => {
                            output += `  - ${item.tripId || 'missing'} (${item.validation.reason})\n`;
                        });
                    }
                    
                    resultsDiv.className = 'verification-results error';
                }
                
                resultsDiv.innerHTML = `<pre>${output}</pre>`;
                
            } catch (error) {
                resultsDiv.className = 'verification-results error';
                resultsDiv.innerHTML = `<pre>Error: ${error.message}\n\nPlease use the manual verification steps above.</pre>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Run Trip Verification';
            }
        }
    </script>
</head>
<body>
    <div class="container">
        <!-- Common Reviewer Navigation -->
        <nav class="reviewer-nav">
            <a href="analysis.html">Data Analysis</a>
            <span>|</span>
            <a href="audit-log.html">Audit Log</a>
            <span>|</span>
            <a href="verify.html" class="active">Verify</a>
            <span>|</span>
            <a href="../research-paper.html">Research</a>
        </nav>

        <div class="header">
            <h1>Trust but Verify</h1>
        </div>

        <div class="section">
            <p>How do you know research data hasn't been manipulated? We provide two independent verifications:</p>
            
            <p><strong>✓ Audit Trail Verification</strong><br>
            Every time data is created, modified, or deleted, a permanent record is written to Google Cloud Storage. This archive is immutable (cannot be changed) and version-locked for 10 years. You can verify that our live database matches this authoritative record.</p>
            
            <p><strong>✓ Device Authentication</strong><br>
            Starting November 8, 2025, every trip record includes a cryptographic signature. This proves it was submitted by a legitimate iOS device with our app installed. You can verify that our database contains only authenticated entries.</p>
            
            <p>These measures provide reviewers with verifiable proof of data integrity. For technical details, see the <a href="../research-paper.html#appendix-data-integrity" target="_blank">research paper appendix</a>.</p>
        </div>

        <div class="section">
            <h2>Section 1: Verify Audit Trail <button id="verifyBtn" class="verify-button" onclick="runVerification()" style="margin-left: 15px;">Run Verification</button></h2>
            <div id="verificationResults" style="display: none; margin-top: 20px;"></div>
        </div>

        <div class="section">
            <h2>Independent Verification: Audit Trail</h2>
            <p>To verify the audit trail on your own computer using the same methodology, follow these steps:</p>
        </div>

        <div class="section">
            <h2>Step 1: Download Firestore Audit Data</h2>
            <p>Export audit entries via Firestore REST API (public read access):</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>curl -s "https://firestore.googleapis.com/v1/projects/jetlagpro-research/databases/(default)/documents/auditLog?pageSize=1000" \
  -o firestore-audit.json</code>
            </div>
            <div class="note">
                <strong>Note:</strong> If the response includes <code>"nextPageToken"</code>, repeat the call with <code>&pageToken=...</code> and append results to the same file.
            </div>
        </div>

        <div class="section">
            <h2>Step 2: Download Immutable GCS Archive using <code>gsutil</code></h2>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>gsutil -m rsync -r gs://jetlagpro-audit-logs/audit-logs ./gcs-audit</code>
            </div>
            <div class="note">
                <strong>Prerequisite:</strong> <code>gsutil</code> is part of the Google Cloud SDK. If not installed:
                <ul style="margin: 8px 0 0 0; padding-left: 20px; line-height: 1.6;">
                    <li><strong>macOS (Homebrew):</strong> <code>brew install google-cloud-sdk</code></li>
                    <li><strong>Linux/Windows:</strong> Download from <a href="https://cloud.google.com/sdk/docs/install" target="_blank">cloud.google.com/sdk/docs/install</a></li>
                </ul>
                After installation, run <code>gcloud init</code> and <code>gcloud auth login</code>. The bucket is publicly readable, so no special permissions are required.
            </div>
            <p>Each JSON file in the archive is a single audit event, version-locked for 10 years.</p>
        </div>

        <div class="section">
            <h2>Step 3: Run Verification Script <a href="https://github.com/SBSchram/jetlagpro-website/blob/main/reviewers/verify.html" target="_blank" class="source-button" style="margin-left: 15px;">View Verification Source Code</a></h2>
            <p>The verification script compares Firestore entries with the GCS archive:</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>python scripts/verify_audit_consistency.py \
  --firestore firestore-audit.json \
  --gcs-dir ./gcs-audit</code>
            </div>
        </div>

        <div class="section">
            <h2>Interpreting Audit Trail Results</h2>
            <ul style="color: #374151; line-height: 1.8;">
                <li><strong>All records match</strong> – Firestore mirrors the immutable archive</li>
                <li><strong>Missing in Firestore</strong> – Unexpected; investigate immediately (GCS is authoritative)</li>
                <li><strong>Missing in GCS</strong> – Unexpected; investigate immediately (all post-deployment entries should exist in both systems)</li>
                <li><strong>Content mismatches</strong> – Potential tampering; investigate immediately (GCS is authoritative)</li>
            </ul>
        </div>

        <div class="section">
            <h2>Section 2: Verify Trip Records from Legitimate iOS Devices <button id="verifyTripBtn" class="verify-button" onclick="runTripVerification()" style="margin-left: 15px;">Run Trip Verification</button></h2>
            <div id="tripVerificationResults" style="display: none; margin-top: 20px;"></div>
        </div>

        <div class="section">
            <h2>Independent Verification: Trip Records</h2>
            <p>To verify our trip records on your own computer, follow these steps:</p>
        </div>

        <div class="section">
            <h2>Step 1: Download Firestore Trip Data</h2>
            <p>Export trip records via Firestore REST API (public read access):</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>curl -s "https://firestore.googleapis.com/v1/projects/jetlagpro-research/databases/(default)/documents/tripCompletions?pageSize=1000" \
  -o firestore-trips.json</code>
            </div>
            <div class="note">
                <strong>Note:</strong> If the response includes <code>"nextPageToken"</code>, repeat the call with <code>&pageToken=...</code> and append results to the same file.
            </div>
        </div>

        <div class="section">
            <h2>Step 2: Run HMAC Verification Script <a href="https://github.com/SBSchram/jetlagpro-website/blob/main/reviewers/verify.html" target="_blank" class="source-button" style="margin-left: 15px;">View Verification Source Code</a></h2>
            <p>The verification script validates HMAC-SHA256 signatures for every trip ID in our dataset:</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>python scripts/verify_trip_signatures.py \
  --firestore firestore-trips.json</code>
            </div>
        </div>

        <div class="section">
            <h2>Interpreting Trip Verification Results</h2>
            <ul style="color: #374151; line-height: 1.8;">
                <li><strong>All signatures valid</strong> – All trip records were submitted by legitimate iOS devices</li>
                <li><strong>Legacy trips (no signature)</strong> – Expected for 20 early records before HMAC was implemented</li>
                <li><strong>Invalid signatures</strong> – Potential tampering or unauthorized submissions; investigate immediately</li>
                <li><strong>Missing trip IDs</strong> – Data integrity issue; investigate immediately</li>
            </ul>
        </div>
    </div>
</body>
</html>

