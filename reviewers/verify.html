<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verify Audit Trail</title>
    <script src="load-reviewer-head.js?v=20251112-01"></script>
    <link rel="stylesheet" href="assets/css/reviewers.css?v=20251112-02">
    <style>
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px 20px 20px 40px;
        }
        .reviewer-nav {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e7eb;
            font-size: 0.9rem;
            text-align: center;
        }
        .reviewer-nav a {
            color: #374151;
            text-decoration: none;
            margin-right: 8px;
        }
        .reviewer-nav a:hover {
            color: #1f2937;
            text-decoration: underline;
        }
        .reviewer-nav a.active {
            color: #1f2937;
            font-weight: 600;
        }
        .reviewer-nav span {
            color: #d1d5db;
            margin: 0 8px;
        }
        .header {
            padding: 0;
            margin-bottom: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #1f2937;
            margin: 0 0 10px 0;
        }
        .header p {
            font-size: 1rem;
            color: #6b7280;
            margin: 0;
        }
        .section {
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 1px solid #e5e7eb;
        }
        .section:last-child {
            border-bottom: none;
        }
        .section h2 {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 15px 0;
        }
        .section p {
            color: #374151;
            line-height: 1.6;
            margin: 0 0 15px 0;
        }
        .code-block {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            overflow-x: auto;
        }
        .code-block code {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #1f2937;
            white-space: pre;
        }
        .example-output {
            background: #f0f9ff;
            border-left: 3px solid #3b82f6;
            padding: 12px 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #1e40af;
        }
        .note {
            background: #fef3c7;
            border-left: 3px solid #f59e0b;
            padding: 12px 15px;
            margin: 15px 0;
            font-size: 0.9rem;
            color: #92400e;
        }
        code {
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
            color: #1f2937;
        }
        .verify-button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .verify-button:hover {
            background: #2563eb;
        }
        .verify-button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .verification-results {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        .verification-results.success {
            background: #f0fdf4;
            border-color: #86efac;
            color: #166534;
        }
        .verification-results.error {
            background: #fef2f2;
            border-color: #fecaca;
            color: #991b1b;
        }
        .verification-results.warning {
            background: #fef3c7;
            border-color: #fde68a;
            color: #92400e;
        }
        .verification-results pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
    <script src="../assets/js/firebase-service.js?v=20251112-05"></script>
    <script>
        async function runVerification() {
            const btn = document.getElementById('verifyBtn');
            const resultsDiv = document.getElementById('verificationResults');
            
            btn.disabled = true;
            btn.textContent = 'Verifying...';
            resultsDiv.style.display = 'block';
            resultsDiv.className = 'verification-results';
            resultsDiv.innerHTML = '<pre>Fetching Firestore audit data...</pre>';
            
            try {
                // Step 1: Fetch Firestore audit entries
                const firebaseService = new FirebaseService();
                const firestoreEntriesRaw = await firebaseService.getAuditLog(10000);
                
                // Normalize Firestore entries to match GCS format
                const firestoreEntries = firestoreEntriesRaw.map(entry => normalizeEntry(entry));
                
                resultsDiv.innerHTML = `<pre>Firestore entries: ${firestoreEntries.length}\nFetching GCS archive...</pre>`;
                
                // Step 2: Fetch GCS audit entries
                // Note: GCS bucket needs to be publicly readable for this to work
                const gcsEntries = await fetchGCSEntries();
                
                if (!gcsEntries || gcsEntries.length === 0) {
                    resultsDiv.className = 'verification-results warning';
                    resultsDiv.innerHTML = `<pre>Firestore entries: ${firestoreEntries.length}
GCS entries: Unable to access (bucket not publicly readable)

The GCS bucket needs to be made publicly readable for web-based verification.

Option 1: Make bucket public (recommended)
Run this command to enable public read access:
  gsutil iam ch allUsers:objectViewer gs://jetlagpro-audit-logs

Option 2: Manual verification
1. Download Firestore data using the curl command above
2. Download GCS archive using gsutil command above
3. Run the verification script locally</pre>`;
                    btn.disabled = false;
                    btn.textContent = 'Run Verification';
                    return;
                }
                
                resultsDiv.innerHTML = `<pre>Firestore entries: ${firestoreEntries.length}
GCS entries: ${gcsEntries.length}
Comparing entries...</pre>`;
                
                // Step 3: Compare entries
                const comparison = compareEntries(firestoreEntries, gcsEntries);
                
                // Step 4: Display results
                let output = `Firestore entries: ${firestoreEntries.length}
GCS entries:       ${gcsEntries.length}
Matched:           ${comparison.matched}
Discrepancies:     ${comparison.discrepancies}

`;
                
                if (comparison.discrepancies === 0) {
                    output += 'Audit verification complete: all records match.';
                    resultsDiv.className = 'verification-results success';
                } else {
                    output += 'DISCREPANCIES FOUND:\n\n';
                    comparison.missingInFirestore.forEach(tripId => {
                        output += `Missing in Firestore: ${tripId}\n`;
                    });
                    comparison.missingInGCS.forEach(tripId => {
                        output += `Missing in GCS: ${tripId}\n`;
                    });
                    comparison.mismatched.forEach(item => {
                        output += `Mismatch: ${item.tripId} (${item.reason})\n`;
                        if (item.details && item.details.length > 0) {
                            item.details.forEach(detail => {
                                output += `  - ${detail}\n`;
                            });
                        }
                    });
                    resultsDiv.className = 'verification-results error';
                }
                
                resultsDiv.innerHTML = `<pre>${output}</pre>`;
                
            } catch (error) {
                resultsDiv.className = 'verification-results error';
                resultsDiv.innerHTML = `<pre>Error: ${error.message}\n\nPlease use the manual verification steps above.</pre>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Run Verification';
            }
        }
        
        async function fetchGCSEntries() {
            try {
                // Try to fetch the GCS bucket listing using JSON API
                // Note: Bucket must be publicly readable
                const listUrl = 'https://storage.googleapis.com/storage/v1/b/jetlagpro-audit-logs/o?prefix=audit-logs/&maxResults=10000';
                console.log('Fetching GCS bucket listing from:', listUrl);
                
                const response = await fetch(listUrl, {
                    cache: 'no-store',
                    method: 'GET'
                });
                
                console.log('GCS API response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('GCS API error response:', errorText);
                    
                    if (response.status === 403) {
                        console.warn('GCS bucket not publicly readable (403 Forbidden)');
                    } else if (response.status === 404) {
                        console.warn('GCS bucket not found (404 Not Found)');
                    } else {
                        console.warn(`GCS API error: ${response.status} ${response.statusText}`);
                    }
                    return null;
                }
                
                const data = await response.json();
                console.log('GCS API returned', data.items?.length || 0, 'items');
                const files = data.items || [];
                
                if (files.length === 0) {
                    console.warn('GCS bucket is accessible but contains no files in audit-logs/ prefix');
                    return [];
                }
                
                // Fetch each JSON file and parse (limit to reasonable number for performance)
                const entries = [];
                const maxFiles = 1000; // Limit to prevent timeout
                const jsonFiles = files.filter(f => f.name.endsWith('.json'));
                const filesToFetch = jsonFiles.slice(0, maxFiles);
                
                console.log(`Fetching ${filesToFetch.length} JSON files from GCS...`);
                
                for (const file of filesToFetch) {
                    try {
                        // Use the mediaLink or construct direct URL
                        const fileUrl = file.mediaLink || `https://storage.googleapis.com/jetlagpro-audit-logs/${file.name}`;
                        const fileResponse = await fetch(fileUrl, {
                            cache: 'no-store'
                        });
                        
                        if (fileResponse.ok) {
                            const entry = await fileResponse.json();
                            // GCS entries are already in plain JSON, but normalize to ensure consistency
                            entries.push(normalizeEntry(entry));
                        } else {
                            console.warn(`Failed to fetch ${file.name}: ${fileResponse.status} ${fileResponse.statusText}`);
                        }
                    } catch (e) {
                        console.warn(`Error fetching ${file.name}:`, e);
                    }
                }
                
                console.log(`Successfully fetched ${entries.length} audit entries from GCS`);
                
                if (jsonFiles.length > maxFiles) {
                    console.warn(`Only fetched first ${maxFiles} of ${jsonFiles.length} JSON files`);
                }
                
                return entries;
            } catch (error) {
                console.error('GCS fetch failed:', error);
                return null;
            }
        }
        
        function compareEntries(firestoreEntries, gcsEntries) {
            const matched = 0;
            const discrepancies = 0;
            const missingInFirestore = [];
            const missingInGCS = [];
            const mismatched = [];
            
            // Create maps for quick lookup (using normalized entries)
            const firestoreMap = new Map();
            firestoreEntries.forEach(entry => {
                // Extract tripId from normalized entry
                const tripId = entry.tripId || entry.documentId || '';
                const operation = entry.operation || 'UNKNOWN';
                const key = `${operation}-${tripId}`;
                firestoreMap.set(key, entry);
            });
            
            const gcsMap = new Map();
            gcsEntries.forEach(entry => {
                // Extract tripId from normalized entry
                const tripId = entry.tripId || entry.documentId || '';
                const operation = entry.operation || 'UNKNOWN';
                const key = `${operation}-${tripId}`;
                gcsMap.set(key, entry);
            });
            
            // Find matches and discrepancies
            let matchedCount = 0;
            const allKeys = new Set([...firestoreMap.keys(), ...gcsMap.keys()]);
            
            allKeys.forEach(key => {
                const firestoreEntry = firestoreMap.get(key);
                const gcsEntry = gcsMap.get(key);
                
                if (!firestoreEntry) {
                    missingInFirestore.push(key);
                } else if (!gcsEntry) {
                    missingInGCS.push(key);
                } else {
                    // Compare normalized entries
                    const firestoreHash = hashEntry(firestoreEntry);
                    const gcsHash = hashEntry(gcsEntry);
                    
                    if (firestoreHash === gcsHash) {
                        matchedCount++;
                    } else {
                        // For debugging, show what fields differ
                        const firestoreNorm = normalizeEntry(firestoreEntry);
                        const gcsNorm = normalizeEntry(gcsEntry);
                        const diffFields = [];
                        const diffDetails = [];
                        
                        const allKeys = new Set([...Object.keys(firestoreNorm), ...Object.keys(gcsNorm)]);
                        for (const k of allKeys) {
                            const fsVal = firestoreNorm[k];
                            const gcsVal = gcsNorm[k];
                            const fsStr = JSON.stringify(fsVal);
                            const gcsStr = JSON.stringify(gcsVal);
                            
                            if (fsStr !== gcsStr) {
                                diffFields.push(k);
                                // For arrays, show length difference
                                if (Array.isArray(fsVal) && Array.isArray(gcsVal)) {
                                    diffDetails.push(`${k}: lengths ${fsVal.length} vs ${gcsVal.length}`);
                                } else if (typeof fsVal === 'object' && typeof gcsVal === 'object') {
                                    // For objects, show key differences
                                    const fsKeys = Object.keys(fsVal || {}).sort();
                                    const gcsKeys = Object.keys(gcsVal || {}).sort();
                                    if (fsKeys.join(',') !== gcsKeys.join(',')) {
                                        diffDetails.push(`${k}: keys differ`);
                                    } else {
                                        diffDetails.push(`${k}: values differ`);
                                    }
                                } else {
                                    diffDetails.push(`${k}: ${typeof fsVal} vs ${typeof gcsVal}`);
                                }
                            }
                        }
                        
                        mismatched.push({
                            tripId: key,
                            reason: diffFields.length > 0 
                                ? `Fields differ: ${diffFields.slice(0, 5).join(', ')}` 
                                : 'Content mismatch',
                            details: diffDetails.slice(0, 3)
                        });
                    }
                }
            });
            
            return {
                matched: matchedCount,
                discrepancies: missingInFirestore.length + missingInGCS.length + mismatched.length,
                missingInFirestore: missingInFirestore.slice(0, 10), // Limit to first 10
                missingInGCS: missingInGCS.slice(0, 10),
                mismatched: mismatched.slice(0, 10)
            };
        }
        
        function normalizeEntry(entry) {
            // Normalize an entry for comparison by:
            // 1. Converting Firestore REST API format to plain values
            // 2. Removing Firestore-specific document metadata
            // 3. Sorting nested object keys for consistent comparison
            // 4. Normalizing timestamps to ISO strings
            // 5. Handling missing fields (set to null for consistent comparison)
            const normalized = {};
            
            // Fields to skip (Firestore document metadata, not part of audit data)
            const skipFields = new Set(['name', 'createTime', 'updateTime', 'id', 'eventId']);
            
            // Get all possible keys from both Firestore and GCS entries
            // For now, we'll just use the keys from this entry
            const keys = Object.keys(entry).sort();
            
            for (const key of keys) {
                // Skip Firestore document metadata
                if (skipFields.has(key)) {
                    continue;
                }
                
                let value = entry[key];
                
                // Convert Firestore REST API format to plain values
                value = extractFirestoreValue(value);
                
                // Normalize timestamp field specifically (and any field that looks like a timestamp)
                if (key === 'timestamp' || key.includes('Time') || key.includes('At')) {
                    value = normalizeTimestamp(value);
                }
                
                // Recursively sort nested object keys for consistent comparison
                if (value && typeof value === 'object' && !Array.isArray(value)) {
                    value = sortObjectKeys(value);
                }
                
                normalized[key] = value;
            }
            
            // Ensure critical fields exist (set to null if missing for consistent comparison)
            // This handles cases where Firestore entries were created before we added these fields
            // Also normalize source to always be a string (not an object)
            if (!('source' in normalized)) {
                normalized.source = null;
            } else if (normalized.source && typeof normalized.source === 'object') {
                // If source is an object (from Firestore REST API), extract the string value
                normalized.source = extractFirestoreValue(normalized.source);
            } else if (normalized.source && typeof normalized.source !== 'string') {
                // Convert to string if it's not already
                normalized.source = String(normalized.source);
            }
            
            if (!('changedFields' in normalized)) {
                normalized.changedFields = null;
            } else if (normalized.changedFields === null) {
                normalized.changedFields = null;
            } else if (!Array.isArray(normalized.changedFields)) {
                // Ensure changedFields is an array (convert if needed)
                normalized.changedFields = [];
            } else {
                // Sort array for consistent comparison
                normalized.changedFields = [...normalized.changedFields].sort();
            }
            
            if (!('changes' in normalized)) {
                normalized.changes = null;
            } else if (normalized.changes && typeof normalized.changes !== 'object') {
                // Ensure changes is an object
                normalized.changes = null;
            }
            
            if (!('deletedData' in normalized)) {
                normalized.deletedData = null;
            }
            
            return normalized;
        }
        
        function sortObjectKeys(obj) {
            // Recursively sort all object keys for consistent comparison
            // Also normalize any timestamp values found in nested structures
            if (obj === null || typeof obj !== 'object') {
                // Check if it's a timestamp string
                if (typeof obj === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(obj)) {
                    return normalizeTimestamp(obj);
                }
                return obj;
            }
            
            if (Array.isArray(obj)) {
                return obj.map(item => sortObjectKeys(item));
            }
            
            const sorted = {};
            const keys = Object.keys(obj).sort();
            for (const key of keys) {
                let value = obj[key];
                
                // Normalize timestamp fields in nested objects
                if (key === 'timestamp' || key.includes('Time') || key.includes('At')) {
                    value = normalizeTimestamp(value);
                }
                
                if (value && typeof value === 'object' && !Array.isArray(value)) {
                    sorted[key] = sortObjectKeys(value);
                } else if (Array.isArray(value)) {
                    sorted[key] = value.map(item => sortObjectKeys(item));
                } else {
                    sorted[key] = value;
                }
            }
            return sorted;
        }
        
        function normalizeTimestamp(value) {
            // Normalize any timestamp value to ISO string
            if (!value) return value;
            
            if (typeof value === 'string') {
                try {
                    const date = new Date(value);
                    if (!isNaN(date.getTime())) {
                        return date.toISOString();
                    }
                } catch (e) {
                    // If parsing fails, return as-is
                }
                return value;
            }
            
            if (typeof value === 'object') {
                // Firestore Timestamp object with _seconds
                if (value._seconds !== undefined) {
                    const seconds = typeof value._seconds === 'number' ? value._seconds : parseInt(value._seconds);
                    return new Date(seconds * 1000).toISOString();
                }
            }
            
            return value;
        }
        
        function extractFirestoreValue(value) {
            // Handle Firestore REST API value types
            if (value === null || value === undefined) {
                return null;
            }
            
            // If it's not an object, check if it's a timestamp string
            if (typeof value !== 'object') {
                // Check if it looks like a timestamp string
                if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value)) {
                    return normalizeTimestamp(value);
                }
                return value;
            }
            
            // Handle Firestore value wrappers (check these first before recursing)
            if (value.timestampValue !== undefined) {
                return normalizeTimestamp(value.timestampValue);
            }
            if (value.stringValue !== undefined) {
                return value.stringValue;
            }
            if (value.integerValue !== undefined) {
                return parseInt(value.integerValue);
            }
            if (value.doubleValue !== undefined) {
                return parseFloat(value.doubleValue);
            }
            if (value.booleanValue !== undefined) {
                return value.booleanValue === 'true' || value.booleanValue === true;
            }
            if (value.nullValue !== undefined) {
                return null;
            }
            if (value.arrayValue && value.arrayValue.values) {
                return value.arrayValue.values.map(v => extractFirestoreValue(v));
            }
            if (value.mapValue && value.mapValue.fields) {
                // Recursively extract nested map
                const nested = {};
                for (const [k, v] of Object.entries(value.mapValue.fields)) {
                    nested[k] = extractFirestoreValue(v);
                }
                return nested;
            }
            
            // Handle Firestore Timestamp objects (from Admin SDK, not REST API)
            if (value._seconds !== undefined) {
                return normalizeTimestamp(value);
            }
            
            // If it's a plain array, recurse
            if (Array.isArray(value)) {
                return value.map(v => extractFirestoreValue(v));
            }
            
            // Plain object - recurse on all values to extract any nested Firestore values
            const result = {};
            for (const [k, v] of Object.entries(value)) {
                result[k] = extractFirestoreValue(v);
            }
            return result;
        }
        
        function hashEntry(entry) {
            // Normalize the entry and create a hash
            const normalized = normalizeEntry(entry);
            // Use JSON.stringify with sorted keys for consistent hashing
            return JSON.stringify(normalized, Object.keys(normalized).sort());
        }
    </script>
</head>
<body>
    <div class="container">
        <!-- Common Reviewer Navigation -->
        <nav class="reviewer-nav">
            <a href="index.html">Reviewer Resources</a>
            <span>|</span>
            <a href="analysis.html">Data Analysis</a>
            <span>|</span>
            <a href="audit-log.html">Audit Log</a>
            <span>|</span>
            <a href="verify.html" class="active">Verify</a>
        </nav>

        <div class="header">
            <h1>Verify Audit Trail</h1>
            <p>Independent verification that Firestore audit entries match the immutable archive</p>
        </div>

        <div class="section">
            <h2>Overview</h2>
            <p>Every audit entry is written to two locations:</p>
            <ul style="color: #374151; line-height: 1.8;">
                <li><strong>Firestore</strong> – Real-time view for the website</li>
                <li><strong>GCS Archive</strong> – Immutable storage with 10-year retention</li>
            </ul>
            <p>Verification confirms these match. The GCS archive is authoritative.</p>
        </div>

        <div class="section">
            <h2>Step 1: Download Firestore Audit Data</h2>
            <p>Export audit entries via Firestore REST API (public read access):</p>
            <div class="code-block">
                <code>curl -s "https://firestore.googleapis.com/v1/projects/jetlagpro-research/databases/(default)/documents/auditLog?pageSize=1000" \
  -o firestore-audit.json</code>
            </div>
            <div class="note">
                <strong>Note:</strong> If the response includes <code>"nextPageToken"</code>, repeat the call with <code>&pageToken=...</code> and append results to the same file.
            </div>
        </div>

        <div class="section">
            <h2>Step 2: Download Immutable GCS Archive</h2>
            <p>Download the immutable archive using <code>gsutil</code>:</p>
            <div class="code-block">
                <code>gsutil -m rsync -r gs://jetlagpro-audit-logs/audit-logs ./gcs-audit</code>
            </div>
            <p>Each JSON file in the archive is a single audit event, version-locked for 10 years.</p>
        </div>

        <div class="section">
            <h2>Step 3: Run Verification Script</h2>
            <p>The verification script compares Firestore entries with the GCS archive:</p>
            <div class="code-block">
                <code>python scripts/verify_audit_consistency.py \
  --firestore firestore-audit.json \
  --gcs-dir ./gcs-audit</code>
            </div>
            <p>The script:</p>
            <ul style="color: #374151; line-height: 1.8;">
                <li>Normalizes Firestore documents into JSON</li>
                <li>Hashes each entry and compares with GCS files</li>
                <li>Reports missing or altered Firestore entries</li>
            </ul>
        </div>

        <div class="section">
            <h2>Run Verification</h2>
            <p>Click the button below to verify the audit trail in real-time:</p>
            <button id="verifyBtn" class="verify-button" onclick="runVerification()">Run Verification</button>
            <div id="verificationResults" style="display: none; margin-top: 20px;"></div>
        </div>

        <div class="section">
            <h2>Interpreting Results</h2>
            <ul style="color: #374151; line-height: 1.8;">
                <li><strong>All records match</strong> – Firestore mirrors the immutable archive</li>
                <li><strong>Discrepancies reported</strong> – Investigate listed entries; GCS is authoritative</li>
            </ul>
        </div>
    </div>
</body>
</html>

