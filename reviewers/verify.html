<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verify Audit Trail</title>
    <script src="../load-common-head.js?v=20251119114529"></script>
    <link rel="stylesheet" href="assets/css/reviewers.css?v=20251119114529">
    <style>
        /* Container override for verify page - narrower for readability */
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px 20px 20px 40px;
        }
        /* Header override for verify page - centered instead of flex */
        .header {
            padding: 0;
            margin-bottom: 15px;
            text-align: center;
            display: block; /* Override flex from reviewers.css */
        }
        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 5px 0;
        }
        .header p {
            font-size: 0.95rem;
            color: #6b7280;
            margin: 0;
        }
    </style>
    <!-- CryptoJS for HMAC-SHA256 validation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="../assets/js/firebase-service.js?v=20251119114529"></script>
    <script src="assets/js/copy-code.js"></script>
    <script>
        
        async function runVerification() {
            const btn = document.getElementById('verifyBtn');
            const resultsDiv = document.getElementById('verificationResults');
            
            btn.disabled = true;
            btn.textContent = 'Verifying...';
            resultsDiv.style.display = 'block';
            resultsDiv.className = 'verification-results';
            resultsDiv.innerHTML = '<pre>Fetching Firestore audit data...</pre>';
            
            try {
                // Step 1: Fetch Firestore audit entries
                const firebaseService = new FirebaseService();
                const firestoreEntriesRaw = await firebaseService.getAuditLog(10000);
                
                // Store raw entries for inspection, then normalize
                const firestoreEntries = firestoreEntriesRaw.map(entry => {
                    // Store raw entry BEFORE normalization (deep copy)
                    const rawEntry = JSON.parse(JSON.stringify(entry));
                    const normalized = normalizeEntry(entry);
                    normalized._raw = rawEntry;
                    return normalized;
                });
                
                resultsDiv.innerHTML = `<pre>Firestore entries: ${firestoreEntries.length}\nFetching GCS archive...</pre>`;
                
                // Step 2: Fetch GCS audit entries
                // Note: GCS bucket needs to be publicly readable for this to work
                const gcsEntries = await fetchGCSEntries();
                
                if (!gcsEntries || gcsEntries.length === 0) {
                    resultsDiv.className = 'verification-results warning';
                    resultsDiv.innerHTML = `<pre>Firestore entries: ${firestoreEntries.length}
GCS entries: Unable to access (bucket not publicly readable)

The GCS bucket needs to be made publicly readable for web-based verification.

Option 1: Make bucket public (recommended)
Run this command to enable public read access:
  gsutil iam ch allUsers:objectViewer gs://jetlagpro-audit-logs

Option 2: Manual verification
1. Download Firestore data using the curl command above
2. Download GCS archive using gsutil command above
3. Run the verification script locally</pre>`;
                    btn.disabled = false;
                    btn.textContent = 'Run Verification';
                    return;
                }
                
                resultsDiv.innerHTML = `<pre>Firestore entries: ${firestoreEntries.length}
GCS entries: ${gcsEntries.length}
Comparing entries...</pre>`;
                
                // Step 3: Compare entries
                const comparison = compareEntries(firestoreEntries, gcsEntries);
                
                // Step 4: Display results
                let output = `AUDIT TRAIL VERIFICATION
======================================================================

DATA SOURCES
Firestore audit entries:    ${comparison.totalFirestoreEntries}
  - Pre-GCS archiving:      ${comparison.preDeploymentCount}
  - GCS archived:          ${comparison.gcsCount}

VERIFICATION RESULTS
GCS entries:               ${comparison.gcsCount}
  Exceptions:               ${comparison.knownExceptionsCount}  (validation failures, documented)
  Matches:                 ${comparison.matched}

Discrepancies:              ${comparison.discrepancies}

`;
                
                if (comparison.discrepancies === 0) {
                    output += 'Status: ✅ Data records match as expected\n';
                    output += '======================================================================';
                    resultsDiv.className = 'verification-results success';
                } else {
                    output += 'DISCREPANCIES FOUND:\n\n';
                    
                    comparison.missingInFirestore.forEach(tripId => {
                        output += `Missing in Firestore: ${tripId}\n`;
                    });
                    comparison.missingInGCS.forEach(tripId => {
                        output += `Missing in GCS: ${tripId}\n`;
                    });
                    comparison.mismatched.forEach(item => {
                        output += `Mismatch: ${item.tripId} (${item.reason})\n`;
                        if (item.details && item.details.length > 0) {
                            item.details.forEach(detail => {
                                output += `  - ${detail}\n`;
                            });
                        }
                        // Add raw data inspection
                        output += `\n=== RAW DATA INSPECTION ===\n`;
                        output += `\nFIRESTORE RAW (first 2000 chars):\n`;
                        output += JSON.stringify(item.rawFirestore, null, 2).substring(0, 2000) + '\n';
                        output += `\nGCS RAW (first 2000 chars):\n`;
                        output += JSON.stringify(item.rawGCS, null, 2).substring(0, 2000) + '\n';
                        output += `\nFIRESTORE NORMALIZED (first 2000 chars):\n`;
                        output += JSON.stringify(item.normalizedFirestore, null, 2).substring(0, 2000) + '\n';
                        output += `\nGCS NORMALIZED (first 2000 chars):\n`;
                        output += JSON.stringify(item.normalizedGCS, null, 2).substring(0, 2000) + '\n';
                        output += `\n=== END INSPECTION ===\n\n`;
                    });
                    resultsDiv.className = 'verification-results error';
                }
                
                resultsDiv.innerHTML = `<pre>${output}</pre>`;
                
            } catch (error) {
                resultsDiv.className = 'verification-results error';
                resultsDiv.innerHTML = `<pre>Error: ${error.message}\n\nPlease use the manual verification steps above.</pre>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Run Verification';
            }
        }
        
        async function fetchGCSEntries() {
            try {
                // Try to fetch the GCS bucket listing using JSON API
                // Note: Bucket must be publicly readable
                const listUrl = 'https://storage.googleapis.com/storage/v1/b/jetlagpro-audit-logs/o?prefix=audit-logs/&maxResults=10000';
                console.log('Fetching GCS bucket listing from:', listUrl);
                
                const response = await fetch(listUrl, {
                    cache: 'no-store',
                    method: 'GET'
                });
                
                console.log('GCS API response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('GCS API error response:', errorText);
                    
                    if (response.status === 403) {
                        console.warn('GCS bucket not publicly readable (403 Forbidden)');
                    } else if (response.status === 404) {
                        console.warn('GCS bucket not found (404 Not Found)');
                    } else {
                        console.warn(`GCS API error: ${response.status} ${response.statusText}`);
                    }
                    return null;
                }
                
                const data = await response.json();
                console.log('GCS API returned', data.items?.length || 0, 'items');
                const files = data.items || [];
                
                if (files.length === 0) {
                    console.warn('GCS bucket is accessible but contains no files in audit-logs/ prefix');
                    return [];
                }
                
                // Fetch each JSON file and parse (limit to reasonable number for performance)
                const entries = [];
                const maxFiles = 1000; // Limit to prevent timeout
                const jsonFiles = files.filter(f => f.name.endsWith('.json'));
                const filesToFetch = jsonFiles.slice(0, maxFiles);
                
                console.log(`Fetching ${filesToFetch.length} JSON files from GCS...`);
                
                for (const file of filesToFetch) {
                    try {
                        // Use the mediaLink or construct direct URL
                        const fileUrl = file.mediaLink || `https://storage.googleapis.com/jetlagpro-audit-logs/${file.name}`;
                        const fileResponse = await fetch(fileUrl, {
                            cache: 'no-store'
                        });
                        
                        if (fileResponse.ok) {
                            const entry = await fileResponse.json();
                            // Store raw entry for inspection
                            const rawEntry = JSON.parse(JSON.stringify(entry));
                            // GCS entries are already in plain JSON, but normalize to ensure consistency
                            const normalized = normalizeEntry(entry);
                            normalized._raw = rawEntry;
                            entries.push(normalized);
                        } else {
                            console.warn(`Failed to fetch ${file.name}: ${fileResponse.status} ${fileResponse.statusText}`);
                        }
                    } catch (e) {
                        console.warn(`Error fetching ${file.name}:`, e);
                    }
                }
                
                console.log(`Successfully fetched ${entries.length} audit entries from GCS`);
                
                if (jsonFiles.length > maxFiles) {
                    console.warn(`Only fetched first ${maxFiles} of ${jsonFiles.length} JSON files`);
                }
                
                return entries;
            } catch (error) {
                console.error('GCS fetch failed:', error);
                return null;
            }
        }
        
        function compareEntries(firestoreEntries, gcsEntries) {
            const matched = 0;
            const discrepancies = 0;
            const missingInFirestore = [];
            const missingInGCS = [];
            const mismatched = [];
            
            // Track counts for reporting
            const totalFirestoreEntries = firestoreEntries.length;
            let preDeploymentCount = 0;
            let knownExceptionsCount = 0;
            
            // Known pre-deployment entries: These 4 audit entries were created before the 
            // immutable GCS archive was deployed (2025-11-11). They exist only in Firestore
            // and are expected to be missing from GCS. We filter them out for verification
            // to avoid false positives. This list is hardcoded for transparency - any future
            // missing entries would indicate a real problem.
            const preDeploymentEventIds = new Set([
                '3479ae2f-5a3f-46ef-9439-f7ca2984337d',
                'dcd41966-3520-486e-93cc-0d50d76e1ac5',
                '1f54b779-aff3-4cd7-b667-ecfdfc898a47',
                '4253d2be-9d13-466f-b535-f55ade5b5dec'
            ]);
            
            // Known validation failures: Validation caught metadata format issues during
            // testing. GCS shows CREATE (original write), Firestore shows validation failure.
            // See verify_audit_consistency.py for details.
            const knownValidationFailures = new Set([
                'a4c3e87d-ffa6-4d9f-86b8-f326c1e7f590'  // Test trip 23DB54B0, 16-char hex device ID
            ]);
            
            // Known field mismatch exceptions: Firestore Admin SDK omits null values when writing,
            // but GCS preserves them. This causes discrepancies where Firestore is missing fields
            // that GCS has. Fixed in Cloud Functions (Nov 20, 2025) - only include fields that exist.
            // These entries are expected discrepancies from before the fix.
            const knownFieldMismatches = new Set([
                '4b073475-b82b-4768-9ad8-57d2056307ca'  // travelDirection missing in Firestore (Nov 20, 2025)
            ]);
            
            // Known eventId collision exceptions: No longer needed - we now use composite keys
            // (operation-documentId) instead of eventId for matching, so multiple entries from the
            // same event are properly handled. Kept for backward compatibility with legacy exclusions.
            const knownEventIdCollisions = new Set([
                // Legacy: No longer needed with composite key matching (Nov 20, 2025)
            ]);
            
            // Create maps for quick lookup using composite key (operation + documentId)
            // This ensures each audit entry is uniquely identified, even when multiple entries
            // share the same eventId (e.g., CREATE and VALIDATION_FAILED from same document creation)
            // The real problem: eventId identifies the source event, not the audit entry.
            // Multiple audit entries can share the same eventId, so we use operation+documentId instead.
            // Also store raw entries for inspection
            const firestoreMap = new Map();
            const firestoreRawMap = new Map();
            firestoreEntries.forEach(entry => {
                // Use composite key: operation + documentId + eventId
                // This uniquely identifies each audit entry:
                // - CREATE/VALIDATION entries can share eventId (same source event), so operation distinguishes them
                // - UPDATE entries have unique eventId per update, so eventId distinguishes them
                // - Using all three ensures uniqueness for all entry types
                const documentId = entry.documentId || entry.tripId || '';
                const operation = entry.operation || 'UNKNOWN';
                const eventId = entry.eventId || entry._raw?.eventId || '';
                const key = `${operation}-${documentId}-${eventId}`;
                
                // Check exclusions by eventId (for backward compatibility with known entries)
                const eventId = entry.eventId || entry._raw?.eventId;
                
                // Skip pre-deployment entries - they're expected to be missing from GCS
                if (eventId && preDeploymentEventIds.has(eventId)) {
                    preDeploymentCount++;
                    return;
                }
                
                // Skip known validation failures - they're expected discrepancies
                if (eventId && knownValidationFailures.has(eventId)) {
                    knownExceptionsCount++;
                    return;
                }
                
                // Skip known field mismatches - Firestore omits null values, GCS preserves them
                // Fixed in Cloud Functions (Nov 20, 2025) - these are pre-fix entries
                if (eventId && knownFieldMismatches.has(eventId)) {
                    knownExceptionsCount++;
                    return;
                }
                
                // Skip known eventId collisions - no longer needed with composite key, but kept for legacy
                if (eventId && knownEventIdCollisions.has(eventId)) {
                    knownExceptionsCount++;
                    return;
                }
                
                firestoreMap.set(key, entry);
                // Store raw entry if available
                if (entry._raw) {
                    firestoreRawMap.set(key, entry._raw);
                }
            });
            
            const gcsMap = new Map();
            const gcsRawMap = new Map();
            gcsEntries.forEach(entry => {
                // Use composite key: operation + documentId + eventId (matches Firestore key generation)
                const documentId = entry.documentId || entry.tripId || '';
                const operation = entry.operation || 'UNKNOWN';
                const eventId = entry.eventId || entry._raw?.eventId || '';
                const key = `${operation}-${documentId}-${eventId}`;
                
                // Skip pre-deployment entries (they shouldn't be in GCS, but filter just in case)
                if (eventId && preDeploymentEventIds.has(eventId)) {
                    return;
                }
                
                // Skip known validation failures - they're expected discrepancies
                if (eventId && knownValidationFailures.has(eventId)) {
                    return;
                }
                
                // Skip known field mismatches - Firestore omits null values, GCS preserves them
                if (eventId && knownFieldMismatches.has(eventId)) {
                    return;
                }
                
                // Skip known eventId collisions - no longer needed with composite key, but kept for legacy
                if (eventId && knownEventIdCollisions.has(eventId)) {
                    return;
                }
                
                gcsMap.set(key, entry);
                // Store raw entry if available
                if (entry._raw) {
                    gcsRawMap.set(key, entry._raw);
                }
            });
            
            // Find matches and discrepancies
            let matchedCount = 0;
            const allKeys = new Set([...firestoreMap.keys(), ...gcsMap.keys()]);
            
            // DEBUG: Log first entry normalization
            const firstKey = Array.from(allKeys)[0];
            if (firstKey) {
                console.log('=== DEBUG: First Entry Normalization ===');
                console.log('Key:', firstKey);
                const fsEntry = firestoreMap.get(firstKey);
                const gcsEntry = gcsMap.get(firstKey);
                if (fsEntry && gcsEntry) {
                    const fsNorm = normalizeEntry(fsEntry);
                    const gcsNorm = normalizeEntry(gcsEntry);
                    console.log('Firestore normalized:', JSON.stringify(fsNorm, null, 2));
                    console.log('GCS normalized:', JSON.stringify(gcsNorm, null, 2));
                    console.log('Firestore hash:', hashEntry(fsEntry));
                    console.log('GCS hash:', hashEntry(gcsEntry));
                    console.log('Match:', hashEntry(fsEntry) === hashEntry(gcsEntry));
                }
                console.log('=== END DEBUG ===');
            }
            
            allKeys.forEach(key => {
                const firestoreEntry = firestoreMap.get(key);
                const gcsEntry = gcsMap.get(key);
                
                if (!firestoreEntry) {
                    missingInFirestore.push(key);
                } else if (!gcsEntry) {
                    missingInGCS.push(key);
                } else {
                    // Compare normalized entries
                    const firestoreHash = hashEntry(firestoreEntry);
                    const gcsHash = hashEntry(gcsEntry);
                    
                    if (firestoreHash === gcsHash) {
                        matchedCount++;
                    } else {
                        // Check exclusions by eventId (for backward compatibility)
                        const fsEventId = firestoreEntry.eventId || firestoreEntry._raw?.eventId;
                        const gcsEventId = gcsEntry.eventId || gcsEntry._raw?.eventId;
                        const eventId = fsEventId || gcsEventId;
                        
                        // Skip known field mismatches and eventId collisions (already filtered above, but double-check here)
                        if (eventId && (knownFieldMismatches.has(eventId) || knownEventIdCollisions.has(eventId))) {
                            knownExceptionsCount++;
                            return;
                        }
                        
                        // For debugging, show what fields differ
                        const firestoreNorm = normalizeEntry(firestoreEntry);
                        const gcsNorm = normalizeEntry(gcsEntry);
                        const diffFields = [];
                        const diffDetails = [];
                        
                        // Store raw entries for inspection (before normalization)
                        const rawFirestore = firestoreRawMap.get(key) || JSON.parse(JSON.stringify(firestoreEntry));
                        const rawGCS = gcsRawMap.get(key) || JSON.parse(JSON.stringify(gcsEntry));
                        
                        const allKeys = new Set([...Object.keys(firestoreNorm), ...Object.keys(gcsNorm)]);
                        for (const k of allKeys) {
                            const fsVal = firestoreNorm[k];
                            const gcsVal = gcsNorm[k];
                            const fsStr = JSON.stringify(fsVal);
                            const gcsStr = JSON.stringify(gcsVal);
                            
                            if (fsStr !== gcsStr) {
                                diffFields.push(k);
                                // For arrays, show length difference
                                if (Array.isArray(fsVal) && Array.isArray(gcsVal)) {
                                    diffDetails.push(`${k}: lengths ${fsVal.length} vs ${gcsVal.length}`);
                                } else if (typeof fsVal === 'object' && typeof gcsVal === 'object') {
                                    // For objects, show key differences
                                    const fsKeys = Object.keys(fsVal || {}).sort();
                                    const gcsKeys = Object.keys(gcsVal || {}).sort();
                                    if (fsKeys.join(',') !== gcsKeys.join(',')) {
                                        diffDetails.push(`${k}: keys differ`);
                                    } else {
                                        diffDetails.push(`${k}: values differ`);
                                    }
                                } else {
                                    diffDetails.push(`${k}: ${typeof fsVal} vs ${typeof gcsVal}`);
                                }
                            }
                        }
                        
                        mismatched.push({
                            tripId: key,
                            reason: diffFields.length > 0 
                                ? `Fields differ: ${diffFields.slice(0, 5).join(', ')}` 
                                : 'Content mismatch',
                            details: diffDetails.slice(0, 3),
                            rawFirestore: rawFirestore,
                            rawGCS: rawGCS,
                            normalizedFirestore: firestoreNorm,
                            normalizedGCS: gcsNorm
                        });
                    }
                }
            });
            
            return {
                matched: matchedCount,
                discrepancies: missingInFirestore.length + missingInGCS.length + mismatched.length,
                missingInFirestore: missingInFirestore.slice(0, 10), // Limit to first 10
                missingInGCS: missingInGCS.slice(0, 10),
                mismatched: mismatched.slice(0, 10),
                totalFirestoreEntries: totalFirestoreEntries,
                preDeploymentCount: preDeploymentCount,
                knownExceptionsCount: knownExceptionsCount,
                gcsCount: gcsEntries.length
            };
        }
        
        function normalizeEntry(entry) {
            // Normalize an entry for comparison by:
            // 1. Converting Firestore REST API format to plain values
            // 2. Removing Firestore-specific document metadata
            // 3. Sorting nested object keys for consistent comparison
            // 4. Normalizing timestamps to ISO strings
            // 5. Handling missing fields (set to null for consistent comparison)
            const normalized = {};
            
            // Fields to skip (Firestore document metadata, not part of audit data)
            // Note: 'eventId' is part of the audit entry, not Firestore metadata, so we keep it
            // Skip '_raw' as it's a duplicate of the top-level fields for debugging
            const skipFields = new Set(['name', 'createTime', 'updateTime', 'id', '_raw']);
            
            // Get all possible keys from both Firestore and GCS entries
            // For now, we'll just use the keys from this entry
            const keys = Object.keys(entry).sort();
            
            for (const key of keys) {
                // Skip Firestore document metadata
                if (skipFields.has(key)) {
                    continue;
                }
                
                let value = entry[key];
                
                // Convert Firestore REST API format to plain values
                value = extractFirestoreValue(value);
                
                // Special handling for source field - ensure it's always a string
                if (key === 'source') {
                    if (value && typeof value === 'object') {
                        // If it's still an object after extraction, try to extract again
                        value = extractFirestoreValue(value);
                    }
                    if (value && typeof value !== 'string') {
                        // Convert to string if not already
                        value = String(value);
                    }
                    if (!value) {
                        value = null;
                    }
                }
                
                // Normalize timestamp field specifically (and any field that looks like a timestamp)
                if (key === 'timestamp' || key.includes('Time') || key.includes('At')) {
                    value = normalizeTimestamp(value);
                }
                
                // Recursively sort nested object keys for consistent comparison
                if (value && typeof value === 'object' && !Array.isArray(value)) {
                    value = sortObjectKeys(value);
                }
                
                normalized[key] = value;
            }
            
            // Ensure critical fields exist (set to null if missing for consistent comparison)
            // This handles cases where Firestore entries were created before we added these fields
            // Also normalize source to always be a string (not an object)
            if (!('source' in normalized)) {
                normalized.source = null;
            } else if (normalized.source && typeof normalized.source === 'object') {
                // If source is an object (from Firestore REST API), extract the string value
                normalized.source = extractFirestoreValue(normalized.source);
            } else if (normalized.source && typeof normalized.source !== 'string') {
                // Convert to string if it's not already
                normalized.source = String(normalized.source);
            }
            
            if (!('changedFields' in normalized)) {
                normalized.changedFields = null;
            } else if (normalized.changedFields === null) {
                normalized.changedFields = null;
            } else if (!Array.isArray(normalized.changedFields)) {
                // Ensure changedFields is an array (convert if needed)
                normalized.changedFields = [];
            } else {
                // Sort array for consistent comparison
                normalized.changedFields = [...normalized.changedFields].sort();
            }
            
            if (!('changes' in normalized)) {
                normalized.changes = null;
            } else if (normalized.changes && typeof normalized.changes !== 'object') {
                // Ensure changes is an object
                normalized.changes = null;
            }
            
            if (!('deletedData' in normalized)) {
                normalized.deletedData = null;
            }
            
            // Normalize metadata structure: ensure surveyMetadata exists for CREATE entries
            // GCS explicitly adds surveyMetadata: null for CREATE entries, but Firestore doesn't store it
            if (normalized.operation === 'CREATE' && normalized.metadata) {
                if (!('surveyMetadata' in normalized.metadata)) {
                    normalized.metadata.surveyMetadata = null;
                }
            }
            
            // Normalize timestamp strings to remove millisecond precision for comparison
            // This handles the fact that GCS might round timestamps differently than Firestore
            const normalizeTimestampString = (str) => {
                if (typeof str !== 'string') return str;
                // Match ISO timestamp with optional milliseconds: 2025-11-12T01:49:14.942Z
                // Pattern: YYYY-MM-DDTHH:mm:ss(.sss)?Z?
                const match = str.match(/^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})(\.\d{1,3})?(Z)?$/);
                if (match) {
                    // Round to seconds: remove milliseconds, keep Z if present
                    return match[1] + (match[3] ? 'Z' : '');
                }
                return str;
            };
            
            // Recursively normalize all timestamp strings in the normalized object
            const normalizeTimestampsInObject = (obj) => {
                if (obj === null || obj === undefined) return obj;
                if (typeof obj === 'string') {
                    return normalizeTimestampString(obj);
                }
                if (Array.isArray(obj)) {
                    return obj.map(item => normalizeTimestampsInObject(item));
                }
                if (typeof obj === 'object') {
                    const result = {};
                    for (const [key, value] of Object.entries(obj)) {
                        // Special handling for timestamp fields
                        if (key === 'timestamp' || key.includes('Time') || key.includes('At')) {
                            result[key] = normalizeTimestampsInObject(value);
                        } else {
                            result[key] = normalizeTimestampsInObject(value);
                        }
                    }
                    return result;
                }
                return obj;
            };
            
            // Apply timestamp normalization
            return normalizeTimestampsInObject(normalized);
        }
        
        function sortObjectKeys(obj) {
            // Recursively sort all object keys for consistent comparison
            // Also normalize any timestamp values found in nested structures
            if (obj === null || typeof obj !== 'object') {
                // Check if it's a timestamp string
                if (typeof obj === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(obj)) {
                    return normalizeTimestamp(obj);
                }
                return obj;
            }
            
            if (Array.isArray(obj)) {
                return obj.map(item => sortObjectKeys(item));
            }
            
            const sorted = {};
            const keys = Object.keys(obj).sort();
            for (const key of keys) {
                let value = obj[key];
                
                // Normalize timestamp fields in nested objects
                if (key === 'timestamp' || key.includes('Time') || key.includes('At')) {
                    value = normalizeTimestamp(value);
                }
                
                if (value && typeof value === 'object' && !Array.isArray(value)) {
                    sorted[key] = sortObjectKeys(value);
                } else if (Array.isArray(value)) {
                    sorted[key] = value.map(item => sortObjectKeys(item));
                } else {
                    sorted[key] = value;
                }
            }
            return sorted;
        }
        
        function normalizeTimestamp(value) {
            // Normalize any timestamp value to ISO string
            if (!value) return value;
            
            if (typeof value === 'string') {
                try {
                    const date = new Date(value);
                    if (!isNaN(date.getTime())) {
                        return date.toISOString();
                    }
                } catch (e) {
                    // If parsing fails, return as-is
                }
                return value;
            }
            
            if (typeof value === 'object') {
                // Firestore Timestamp object with _seconds
                if (value._seconds !== undefined) {
                    const seconds = typeof value._seconds === 'number' ? value._seconds : parseInt(value._seconds);
                    return new Date(seconds * 1000).toISOString();
                }
            }
            
            return value;
        }
        
        function extractFirestoreValue(value) {
            // Handle Firestore REST API value types
            if (value === null || value === undefined) {
                return null;
            }
            
            // If it's not an object, check if it's a timestamp string
            if (typeof value !== 'object') {
                // Check if it looks like a timestamp string
                if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value)) {
                    return normalizeTimestamp(value);
                }
                return value;
            }
            
            // Handle Firestore value wrappers (check these first before recursing)
            if (value.timestampValue !== undefined) {
                return normalizeTimestamp(value.timestampValue);
            }
            if (value.stringValue !== undefined) {
                return value.stringValue;
            }
            if (value.integerValue !== undefined) {
                return parseInt(value.integerValue);
            }
            if (value.doubleValue !== undefined) {
                return parseFloat(value.doubleValue);
            }
            if (value.booleanValue !== undefined) {
                return value.booleanValue === 'true' || value.booleanValue === true;
            }
            if (value.nullValue !== undefined) {
                return null;
            }
            if (value.arrayValue && value.arrayValue.values) {
                return value.arrayValue.values.map(v => extractFirestoreValue(v));
            }
            if (value.mapValue && value.mapValue.fields) {
                // Recursively extract nested map
                const nested = {};
                for (const [k, v] of Object.entries(value.mapValue.fields)) {
                    nested[k] = extractFirestoreValue(v);
                }
                return nested;
            }
            
            // Handle Firestore Timestamp objects (from Admin SDK, not REST API)
            if (value._seconds !== undefined) {
                return normalizeTimestamp(value);
            }
            
            // If it's a plain array, recurse
            if (Array.isArray(value)) {
                return value.map(v => extractFirestoreValue(v));
            }
            
            // Plain object - recurse on all values to extract any nested Firestore values
            const result = {};
            for (const [k, v] of Object.entries(value)) {
                result[k] = extractFirestoreValue(v);
            }
            return result;
        }
        
        function hashEntry(entry) {
            // Normalize the entry and create a hash
            const normalized = normalizeEntry(entry);
            // Use JSON.stringify with sorted keys for consistent hashing
            return JSON.stringify(normalized, Object.keys(normalized).sort());
        }
        
        // HMAC-SHA256 secret key (same as in iOS app and trip-validator.js)
        // 
        // INTENTIONALLY PUBLIC FOR RESEARCH TRANSPARENCY
        // 
        // This key is exposed by design, not by accident. Here's why:
        // 
        // 1. NOT FOR SECURITY: This key doesn't protect sensitive data or control access.
        //    All trip data is already publicly viewable on the dashboard.
        // 
        // 2. FOR VERIFICATION: Independent reviewers need this key to verify that trip IDs
        //    follow the documented HMAC-SHA256 format, confirming our implementation claims.
        // 
        // 3. FOR TRANSPARENCY: Research requires reproducible methods. Hiding the key would
        //    prevent independent verification of our cryptographic approach.
        // 
        // 4. WHAT IT PROTECTS: The key ensures trip IDs are consistently generated using
        //    HMAC (not random UUIDs), providing format verification and collision resistance.
        // 
        // 5. WHAT IT DOESN'T PROTECT: It doesn't prevent fake trips (server validates),
        //    doesn't control access (data is public), and doesn't encrypt anything.
        // 
        // In typical security contexts, exposing secrets is wrong. In research verification,
        // hiding the algorithm would undermine transparency and reproducibility.
        const HMAC_SECRET = '7f3a9d8b2c4e1f6a5d8b3c9e7f2a4d6b8c1e3f5a7d9b2c4e6f8a1d3b5c7e9f2a';
        
        /**
         * Validates HMAC-SHA256 signature on a trip ID
         * Trip IDs from Build 6+ have format: deviceID-dest-date-time-signature
         */
        function validateTripHMAC(tripId) {
            if (!tripId) {
                return { valid: false, reason: 'missing_trip_id', category: 'error' };
            }
            
            const parts = tripId.split('-');
            
            // Check for UUID format (legacy, very old trips)
            if (parts.length === 5 && 
                parts[0].length === 8 && 
                parts[1].length === 4 && 
                parts[2].length === 4 && 
                parts[3].length === 4 && 
                parts[4].length === 12) {
                return { 
                    valid: true, 
                    reason: 'legacy_uuid_format', 
                    category: 'legacy',
                    tripId: tripId
                };
            }
            
            // Legacy format (4 parts): Pre-Build 6 data without signatures
            if (parts.length === 4) {
                return { 
                    valid: true, 
                    reason: 'legacy_no_signature', 
                    category: 'legacy',
                    tripId: tripId
                };
            }
            
            // November 8, 2025 and later format (5 parts): deviceID-dest-date-time-signature
            if (parts.length === 5) {
                const baseTripId = parts.slice(0, 4).join('-');
                const providedSignature = parts[4];
                
                // Validate signature format (8 hex characters)
                if (!/^[a-fA-F0-9]{8}$/.test(providedSignature)) {
                    return { 
                        valid: false, 
                        reason: 'invalid_signature_format', 
                        category: 'invalid',
                        tripId: tripId,
                        providedSignature: providedSignature
                    };
                }
                
                // Check if CryptoJS is available
                if (typeof CryptoJS === 'undefined') {
                    return { 
                        valid: true, // Assume valid if we can't verify
                        reason: 'crypto_unavailable', 
                        category: 'unverified',
                        tripId: tripId
                    };
                }
                
                // Compute expected signature
                const hmac = CryptoJS.HmacSHA256(baseTripId, HMAC_SECRET);
                const expectedSignature = hmac.toString(CryptoJS.enc.Hex).substring(0, 8).toLowerCase();
                
                if (providedSignature.toLowerCase() === expectedSignature) {
                    return { 
                        valid: true, 
                        reason: 'valid_signature', 
                        category: 'authenticated',
                        tripId: tripId,
                        signature: providedSignature
                    };
                } else {
                    return { 
                        valid: false, 
                        reason: 'signature_mismatch', 
                        category: 'invalid',
                        tripId: tripId,
                        expected: expectedSignature,
                        provided: providedSignature
                    };
                }
            }
            
            // Unexpected format
            return { 
                valid: false, 
                reason: 'unexpected_format', 
                category: 'error',
                tripId: tripId,
                parts: parts.length
            };
        }
        
        async function runTripVerification() {
            const btn = document.getElementById('verifyTripBtn');
            const resultsDiv = document.getElementById('tripVerificationResults');
            
            btn.disabled = true;
            btn.textContent = 'Verifying...';
            resultsDiv.style.display = 'block';
            resultsDiv.className = 'verification-results';
            resultsDiv.innerHTML = '<pre>Fetching Firestore trip data...</pre>';
            
            try {
                // Step 1: Fetch Firestore trip records
                const firebaseService = new FirebaseService();
                const trips = await firebaseService.getTripCompletions();
                
                resultsDiv.innerHTML = `<pre>Trip records: ${trips.length}\nValidating HMAC signatures...</pre>`;
                
                // Step 2: Validate HMAC signatures
                const categories = {
                    authenticated: [],  // November 8, 2025 and later with valid signatures
                    legacy: [],         // Before November 8, 2025 without signatures
                    invalid: [],        // Invalid or mismatched signatures
                    error: []          // Missing trip IDs or malformed
                };
                
                trips.forEach(trip => {
                    const tripId = trip.tripId || trip.documentId || '';
                    const validation = validateTripHMAC(tripId);
                    categories[validation.category].push({
                        tripId: tripId,
                        documentId: trip.documentId || trip.id || 'unknown',
                        validation: validation
                    });
                });
                
                // Step 3: Display results
                let output = `Trip records: ${trips.length}

HMAC Validation Results:
  Authenticated (valid signatures): ${categories.authenticated.length}
  Legacy data (expect only 20) prior to HMAC: ${categories.legacy.length}
  Invalid (signature mismatch): ${categories.invalid.length}
  Error (malformed trip IDs): ${categories.error.length}

`;
                
                if (categories.invalid.length === 0 && categories.error.length === 0) {
                    output += 'Trip verification complete: all signatures are valid or legacy.';
                    resultsDiv.className = 'verification-results success';
                } else {
                    output += 'INVALID SIGNATURES FOUND:\n\n';
                    
                    if (categories.invalid.length > 0) {
                        output += `Invalid Signatures (${categories.invalid.length}):\n`;
                        categories.invalid.forEach(item => {
                            output += `  - ${item.tripId}\n`;
                            if (item.validation.expected && item.validation.provided) {
                                output += `    Expected: ${item.validation.expected}\n`;
                                output += `    Provided: ${item.validation.provided}\n`;
                            }
                        });
                        output += '\n';
                    }
                    
                    if (categories.error.length > 0) {
                        output += `Malformed Trip IDs (${categories.error.length}):\n`;
                        categories.error.forEach(item => {
                            output += `  - ${item.tripId || 'missing'} (${item.validation.reason})\n`;
                        });
                    }
                    
                    resultsDiv.className = 'verification-results error';
                }
                
                resultsDiv.innerHTML = `<pre>${output}</pre>`;
                
            } catch (error) {
                resultsDiv.className = 'verification-results error';
                resultsDiv.innerHTML = `<pre>Error: ${error.message}\n\nPlease use the manual verification steps above.</pre>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Run Trip Verification';
            }
        }
    </script>
</head>
<body>
    <div class="container">
        <!-- Common Reviewer Navigation (loaded dynamically) -->
        <script src="load-nav.js?v=20251119134740"></script>

        <div class="header">
            <h1>Trust but Verify</h1>
        </div>

        <div class="section">
            <p>How do you know research data hasn't been manipulated? We provide two independent verifications:</p>
            
            <p><strong>✓ Audit Trail Verification</strong><br>
            Every time data is created, modified, or deleted, a permanent record is written to Google Cloud Storage. This archive is immutable (cannot be changed) and version-locked for 10 years. You can verify that our live database matches this authoritative record.</p>
            
            <p><strong>✓ Device Authentication</strong><br>
            Starting November 8, 2025, every trip record includes a cryptographic signature. This proves it was submitted by a legitimate iOS device with our app installed. You can verify that our database contains only authenticated entries.</p>
            
            <p>These measures provide reviewers with verifiable proof of data integrity. For technical details, see the <a href="../research-paper.html#appendix-data-integrity" target="_blank">research paper appendix</a>.</p>
        </div>

        <div class="section">
            <h2>Section 1: Verify Audit Trail <button id="verifyBtn" class="verify-button" onclick="runVerification()" style="margin-left: 15px;">Run Verification</button></h2>
            <div id="verificationResults" style="display: none; margin-top: 20px;"></div>
        </div>

        <div class="section">
            <h2>Independent Verification: Audit Trail</h2>
            <p>To verify the audit trail on your own computer using the same methodology, follow these steps:</p>
        </div>

        <div class="section">
            <h2>Step 1: Download Firestore Audit Data</h2>
            <p>Export audit entries via Firestore REST API (public read access):</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>curl -s "https://firestore.googleapis.com/v1/projects/jetlagpro-research/databases/(default)/documents/auditLog?pageSize=1000" \
  -o firestore-audit.json</code>
            </div>
            <div class="note">
                <strong>Note:</strong> If the response includes <code>"nextPageToken"</code>, repeat the call with <code>&pageToken=...</code> and append results to the same file.
            </div>
        </div>

        <div class="section">
            <h2>Step 2: Download Immutable GCS Archive <span style="color: #666; font-size: 0.8em; font-weight: normal;">(Optional - Skip to Step 3)</span></h2>
            <p style="margin-bottom: 10px; color: #666; font-size: 0.95em;"><strong>Note:</strong> Step 2 is optional. The verification script in Step 3 will automatically download GCS files for you. Only use this step if you prefer manual control with gsutil.</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>gsutil -m rsync -r gs://jetlagpro-audit-logs/audit-logs ./gcs-audit</code>
            </div>
            <div class="note" style="margin-top: 10px;">
                <strong>Prerequisite:</strong> <code>gsutil</code> is part of the Google Cloud SDK. If not installed:
                <ul style="margin: 8px 0 0 0; padding-left: 20px; line-height: 1.6;">
                    <li><strong>macOS (Homebrew):</strong> <code>brew install google-cloud-sdk</code></li>
                    <li><strong>Linux/Windows:</strong> Download from <a href="https://cloud.google.com/sdk/docs/install" target="_blank">cloud.google.com/sdk/docs/install</a></li>
                </ul>
                After installation, run <code>gcloud init</code> and <code>gcloud auth login</code>. The bucket is publicly readable, so no special permissions are required.
            </div>
            <p style="margin-top: 10px; font-size: 0.9em;">Each JSON file in the archive is a single audit event, version-locked for 10 years.</p>
        </div>

        <div class="section">
            <h2>Step 3: Download and Run Verification Script</h2>
            <p>Download the standalone verification script (no dependencies, pure Python):</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>curl -o verify_audit_consistency.py \
  https://jetlagpro.com/scripts/verify_audit_consistency.py</code>
            </div>
            <p style="margin-top: 15px;"><a href="https://github.com/SBSchram/jetlagpro-website/blob/main/scripts/verify_audit_consistency.py" target="_blank" class="source-button">View Source Code on GitHub</a></p>
            <p style="margin-top: 15px;">Run the verification script. It will automatically download GCS files (no gsutil required):</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>python verify_audit_consistency.py --firestore firestore-audit.json</code>
            </div>
            <p style="margin-top: 10px; font-size: 0.9em; color: #666;"><strong>That's it!</strong> The script automatically downloads GCS files and verifies consistency. No gsutil, no manual downloads, no complex setup.</p>
            <details style="margin-top: 15px;">
                <summary style="cursor: pointer; color: #0066cc; font-size: 0.9em;">Advanced: Use manual gsutil download (optional)</summary>
                <p style="margin-top: 10px; font-size: 0.9em;">If you prefer to use gsutil from Step 2:</p>
                <div class="code-block" style="margin-top: 8px;">
                    <code>python verify_audit_consistency.py --firestore firestore-audit.json --gcs-dir ./gcs-audit</code>
                </div>
            </details>
        </div>

        <div class="section">
            <h2>Interpreting Audit Trail Results</h2>
            <ul style="color: #374151; line-height: 1.8;">
                <li><strong>All records match</strong> – Firestore mirrors the immutable archive</li>
                <li><strong>Missing in Firestore</strong> – Unexpected; investigate immediately (GCS is authoritative)</li>
                <li><strong>Missing in GCS</strong> – Unexpected; investigate immediately (all post-deployment entries should exist in both systems)</li>
                <li><strong>Content mismatches</strong> – Potential tampering; investigate immediately (GCS is authoritative)</li>
            </ul>
        </div>

        <div class="section">
            <h2>Section 2: Verify Trip Records from Legitimate iOS Devices <button id="verifyTripBtn" class="verify-button" onclick="runTripVerification()" style="margin-left: 15px;">Run Trip Verification</button></h2>
            <div id="tripVerificationResults" style="display: none; margin-top: 20px;"></div>
        </div>

        <div class="section">
            <h2>Independent Verification: Trip Records</h2>
            <p>To verify our trip records on your own computer, follow these steps:</p>
        </div>

        <div class="section">
            <h2>Step 1: Download Firestore Trip Data</h2>
            <p>Export trip records via Firestore REST API (public read access):</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>curl -s "https://firestore.googleapis.com/v1/projects/jetlagpro-research/databases/(default)/documents/tripCompletions?pageSize=1000" \
  -o firestore-trips.json</code>
            </div>
            <div class="note">
                <strong>Note:</strong> If the response includes <code>"nextPageToken"</code>, repeat the call with <code>&pageToken=...</code> and append results to the same file.
            </div>
        </div>

        <div class="section">
            <h2>Step 2: Download and Run HMAC Verification Script</h2>
            <p>Download the standalone verification script (no dependencies, pure Python):</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>curl -o verify_trip_signatures.py \
  https://jetlagpro.com/scripts/verify_trip_signatures.py</code>
            </div>
            <p style="margin-top: 15px;"><a href="https://github.com/SBSchram/jetlagpro-website/blob/main/scripts/verify_trip_signatures.py" target="_blank" class="source-button">View Source Code on GitHub</a></p>
            <p style="margin-top: 15px;">Run the verification script to validate HMAC-SHA256 signatures for every trip ID in our dataset:</p>
            <div class="code-block">
                <button class="copy-button" onclick="copyCode(this)" title="Copy to clipboard">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </button>
                <code>python verify_trip_signatures.py \
  --trips firestore-trips.json \
  --secret-key [CONTACT_AUTHORS_FOR_KEY]</code>
            </div>
            <div class="note">
                <strong>Note:</strong> The secret key is required for signature verification. Contact the study authors to obtain the key for independent verification.
            </div>
        </div>

        <div class="section">
            <h2>Interpreting Trip Verification Results</h2>
            <ul style="color: #374151; line-height: 1.8;">
                <li><strong>All signatures valid</strong> – All trip records were submitted by legitimate iOS devices</li>
                <li><strong>Legacy trips (no signature)</strong> – Expected for 20 early records before HMAC was implemented</li>
                <li><strong>Invalid signatures</strong> – Potential tampering or unauthorized submissions; investigate immediately</li>
                <li><strong>Missing trip IDs</strong> – Data integrity issue; investigate immediately</li>
            </ul>
        </div>
    </div>
</body>
</html>

